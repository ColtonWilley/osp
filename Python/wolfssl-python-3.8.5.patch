diff -Naur a/configure b/configure
--- a/configure	2021-09-16 08:35:22.270328788 -0700
+++ b/configure	2021-08-26 15:42:06.510758000 -0700
@@ -842,6 +842,7 @@
 enable_big_digits
 with_computed_gotos
 with_ensurepip
+with_wolfssl
 with_openssl
 with_ssl_default_suites
 '
@@ -1555,6 +1556,7 @@
                           default on supported compilers)
   --with(out)-ensurepip=[=upgrade]
                           "install" or "upgrade" using bundled pip
+  --with-wolfssl=DIR      build with wolfSSL at DIR instead of OpenSSL
   --with-openssl=DIR      root of the OpenSSL directory
   --with-ssl-default-suites=[python|openssl|STRING]
                           Override default cipher suites string, python: use
@@ -17091,7 +17093,62 @@
 LIBS="$save_LIBS"
 ac_includes_default="$save_includes_default"
 
-# Check for usable OpenSSL
+# Check if building with wolfSSL, otherwise default to trying OpenSSL
+
+# Check whether --with-wolfssl was given.
+if test "${with_wolfssl+set}" = set; then :
+  withval=$with_wolfssl;
+    OPENSSL_INCLUDES="-I${withval}/include/wolfssl -I${withval}/include/"
+    OPENSSL_LDFLAGS="-L${withval}/lib"
+    OPENSSL_LIBS="-lwolfssl"
+
+    # AC_SUBST calls required to substitute other uses of OPENSSL_* vars
+
+
+
+
+    CPPFLAGS="$CPPFLAGS $OPENSSL_INCLUDES"
+    LDFLAGS="$LDFLAGS $OPENSSL_LDFLAGS"
+    LIBS="$LIBS $OPENSSL_LIBS"
+
+    USE_WOLFSSL=yes
+else
+
+    USE_WOLFSSL=no
+
+fi
+
+
+if test $USE_WOLFSSL = yes
+then
+    ac_fn_c_check_header_mongrel "$LINENO" "wolfssl/options.h" "ac_cv_header_wolfssl_options_h" "$ac_includes_default"
+if test "x$ac_cv_header_wolfssl_options_h" = xyes; then :
+
+fi
+
+
+    if test $ac_cv_header_wolfssl_options_h = yes
+    then
+
+$as_echo "#define HAVE_WOLFSSL 1" >>confdefs.h
+
+        $as_echo "#define HAVE_X509_VERIFY_PARAM_SET1_HOST 1" >>confdefs.h
+
+
+        # Note we are disabling compression when using wolfSSL
+
+$as_echo "#define OPENSSL_NO_COMP 1" >>confdefs.h
+
+
+        # Note we are disabling scrypt until EVP_PBE_scrypt API gets implemented
+
+$as_echo "#define OPENSSL_NO_SCRYPT 1" >>confdefs.h
+
+    else
+        as_fn_error $? "Unable to find wolfSSL" "$LINENO" 5
+    fi
+else
+    # Check for usable OpenSSL
 
     found=false
 
@@ -17296,30 +17353,30 @@
 
 
 
-if test "$have_openssl" = yes; then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X509_VERIFY_PARAM_set1_host in libssl" >&5
+    if test "$have_openssl" = yes; then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for X509_VERIFY_PARAM_set1_host in libssl" >&5
 $as_echo_n "checking for X509_VERIFY_PARAM_set1_host in libssl... " >&6; }
 
-    save_LIBS="$LIBS"
-    save_LDFLAGS="$LDFLAGS"
-    save_CPPFLAGS="$CPPFLAGS"
-    LDFLAGS="$LDFLAGS $OPENSSL_LDFLAGS"
-    LIBS="$OPENSSL_LIBS $LIBS"
-    CPPFLAGS="$OPENSSL_INCLUDES $CPPFLAGS"
+        save_LIBS="$LIBS"
+        save_LDFLAGS="$LDFLAGS"
+        save_CPPFLAGS="$CPPFLAGS"
+        LDFLAGS="$LDFLAGS $OPENSSL_LDFLAGS"
+        LIBS="$OPENSSL_LIBS $LIBS"
+        CPPFLAGS="$OPENSSL_INCLUDES $CPPFLAGS"
 
-    cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
-        #include <openssl/x509_vfy.h>
+            #include <openssl/x509_vfy.h>
 
 int
 main ()
 {
 
-        X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();
-        X509_VERIFY_PARAM_set1_host(p, "localhost", 0);
-        X509_VERIFY_PARAM_set1_ip_asc(p, "127.0.0.1");
-        X509_VERIFY_PARAM_set_hostflags(p, 0);
+            X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();
+            X509_VERIFY_PARAM_set1_host(p, "localhost", 0);
+            X509_VERIFY_PARAM_set1_ip_asc(p, "127.0.0.1");
+            X509_VERIFY_PARAM_set_hostflags(p, 0);
 
   ;
   return 0;
@@ -17328,26 +17385,27 @@
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
 
-        ac_cv_has_x509_verify_param_set1_host=yes
+            ac_cv_has_x509_verify_param_set1_host=yes
 
 else
 
-        ac_cv_has_x509_verify_param_set1_host=no
+            ac_cv_has_x509_verify_param_set1_host=no
 
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-    { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_has_x509_verify_param_set1_host" >&5
+        { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_has_x509_verify_param_set1_host" >&5
 $as_echo "$ac_cv_has_x509_verify_param_set1_host" >&6; }
-    if test "$ac_cv_has_x509_verify_param_set1_host" = "yes"; then
+        if test "$ac_cv_has_x509_verify_param_set1_host" = "yes"; then
 
 $as_echo "#define HAVE_X509_VERIFY_PARAM_SET1_HOST 1" >>confdefs.h
 
-    fi
+        fi
 
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
+        CPPFLAGS="$save_CPPFLAGS"
+        LDFLAGS="$save_LDFLAGS"
+        LIBS="$save_LIBS"
+    fi
 fi
 
 # ssl module default cipher suite string
diff -Naur a/configure.ac b/configure.ac
--- a/configure.ac	2021-09-16 08:35:22.270328788 -0700
+++ b/configure.ac	2021-08-26 15:42:06.524087000 -0700
@@ -5571,43 +5571,84 @@
 LIBS="$save_LIBS"
 ac_includes_default="$save_includes_default"
 
-# Check for usable OpenSSL
-AX_CHECK_OPENSSL([have_openssl=yes],[have_openssl=no])
+# Check if building with wolfSSL, otherwise default to trying OpenSSL
+AC_ARG_WITH(wolfssl,
+            AS_HELP_STRING([--with-wolfssl]=DIR,
+                           [build with wolfSSL at DIR instead of OpenSSL]),
+[
+    OPENSSL_INCLUDES="-I${withval}/include/wolfssl -I${withval}/include/"
+    OPENSSL_LDFLAGS="-L${withval}/lib"
+    OPENSSL_LIBS="-lwolfssl"
+
+    # AC_SUBST calls required to substitute other uses of OPENSSL_* vars
+    AC_SUBST([OPENSSL_INCLUDES])
+    AC_SUBST([OPENSSL_LIBS])
+    AC_SUBST([OPENSSL_LDFLAGS])
 
-if test "$have_openssl" = yes; then
-    AC_MSG_CHECKING([for X509_VERIFY_PARAM_set1_host in libssl])
-
-    save_LIBS="$LIBS"
-    save_LDFLAGS="$LDFLAGS"
-    save_CPPFLAGS="$CPPFLAGS"
+    CPPFLAGS="$CPPFLAGS $OPENSSL_INCLUDES"
     LDFLAGS="$LDFLAGS $OPENSSL_LDFLAGS"
-    LIBS="$OPENSSL_LIBS $LIBS"
-    CPPFLAGS="$OPENSSL_INCLUDES $CPPFLAGS"
+    LIBS="$LIBS $OPENSSL_LIBS"
 
-    AC_LINK_IFELSE([AC_LANG_PROGRAM([
-        [#include <openssl/x509_vfy.h>]
-    ], [
-        [X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();]
-        [X509_VERIFY_PARAM_set1_host(p, "localhost", 0);]
-        [X509_VERIFY_PARAM_set1_ip_asc(p, "127.0.0.1");]
-        [X509_VERIFY_PARAM_set_hostflags(p, 0);]
-    ])
-    ],
-    [
-        ac_cv_has_x509_verify_param_set1_host=yes
-    ],
-    [
-        ac_cv_has_x509_verify_param_set1_host=no
-    ])
-    AC_MSG_RESULT($ac_cv_has_x509_verify_param_set1_host)
-    if test "$ac_cv_has_x509_verify_param_set1_host" = "yes"; then
-        AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1,
-        [Define if libssl has X509_VERIFY_PARAM_set1_host and related function])
+    USE_WOLFSSL=yes],
+[
+    USE_WOLFSSL=no
+])
+
+if test $USE_WOLFSSL = yes
+then
+    AC_CHECK_HEADER([wolfssl/options.h])
+    if test $ac_cv_header_wolfssl_options_h = yes
+    then
+        AC_DEFINE(HAVE_WOLFSSL, 1, [define if you are using wolfSSL])
+        AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1, [])
+
+        # Note we are disabling compression when using wolfSSL
+        AC_DEFINE([OPENSSL_NO_COMP], 1, [define to disable compression])
+
+        # Note we are disabling scrypt until EVP_PBE_scrypt API gets implemented
+        AC_DEFINE([OPENSSL_NO_SCRYPT], 1, [define to disable scrypt])
+    else
+        AC_MSG_ERROR([Unable to find wolfSSL])
+    fi
+else
+    # Check for usable OpenSSL
+    AX_CHECK_OPENSSL([have_openssl=yes],[have_openssl=no])
+
+    if test "$have_openssl" = yes; then
+        AC_MSG_CHECKING([for X509_VERIFY_PARAM_set1_host in libssl])
+
+        save_LIBS="$LIBS"
+        save_LDFLAGS="$LDFLAGS"
+        save_CPPFLAGS="$CPPFLAGS"
+        LDFLAGS="$LDFLAGS $OPENSSL_LDFLAGS"
+        LIBS="$OPENSSL_LIBS $LIBS"
+        CPPFLAGS="$OPENSSL_INCLUDES $CPPFLAGS"
+
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([
+            [#include <openssl/x509_vfy.h>]
+        ], [
+            [X509_VERIFY_PARAM *p = X509_VERIFY_PARAM_new();]
+            [X509_VERIFY_PARAM_set1_host(p, "localhost", 0);]
+            [X509_VERIFY_PARAM_set1_ip_asc(p, "127.0.0.1");]
+            [X509_VERIFY_PARAM_set_hostflags(p, 0);]
+        ])
+        ],
+        [
+            ac_cv_has_x509_verify_param_set1_host=yes
+        ],
+        [
+            ac_cv_has_x509_verify_param_set1_host=no
+        ])
+        AC_MSG_RESULT($ac_cv_has_x509_verify_param_set1_host)
+        if test "$ac_cv_has_x509_verify_param_set1_host" = "yes"; then
+            AC_DEFINE(HAVE_X509_VERIFY_PARAM_SET1_HOST, 1,
+            [Define if libssl has X509_VERIFY_PARAM_set1_host and related function])
+        fi
+
+        CPPFLAGS="$save_CPPFLAGS"
+        LDFLAGS="$save_LDFLAGS"
+        LIBS="$save_LIBS"
     fi
-
-    CPPFLAGS="$save_CPPFLAGS"
-    LDFLAGS="$save_LDFLAGS"
-    LIBS="$save_LIBS"
 fi
 
 # ssl module default cipher suite string
diff -Naur a/Lib/ssl.py b/Lib/ssl.py
--- a/Lib/ssl.py	2021-09-16 08:35:22.486320383 -0700
+++ b/Lib/ssl.py	2021-09-03 12:45:02.422874525 -0700
@@ -117,6 +117,7 @@
     HAS_TLSv1_1, HAS_TLSv1_2, HAS_TLSv1_3
 )
 from _ssl import _DEFAULT_CIPHERS, _OPENSSL_API_VERSION
+from _ssl import IS_WOLFSSL
 
 
 _IntEnum._convert_(
diff -Naur a/Lib/test/capath-2048-plus/5ed36f99.0 b/Lib/test/capath-2048-plus/5ed36f99.0
--- a/Lib/test/capath-2048-plus/5ed36f99.0	1969-12-31 16:00:00.000000000 -0800
+++ b/Lib/test/capath-2048-plus/5ed36f99.0	2021-08-26 15:41:59.478462000 -0700
@@ -0,0 +1,41 @@
+-----BEGIN CERTIFICATE-----
+MIIHPTCCBSWgAwIBAgIBADANBgkqhkiG9w0BAQQFADB5MRAwDgYDVQQKEwdSb290
+IENBMR4wHAYDVQQLExVodHRwOi8vd3d3LmNhY2VydC5vcmcxIjAgBgNVBAMTGUNB
+IENlcnQgU2lnbmluZyBBdXRob3JpdHkxITAfBgkqhkiG9w0BCQEWEnN1cHBvcnRA
+Y2FjZXJ0Lm9yZzAeFw0wMzAzMzAxMjI5NDlaFw0zMzAzMjkxMjI5NDlaMHkxEDAO
+BgNVBAoTB1Jvb3QgQ0ExHjAcBgNVBAsTFWh0dHA6Ly93d3cuY2FjZXJ0Lm9yZzEi
+MCAGA1UEAxMZQ0EgQ2VydCBTaWduaW5nIEF1dGhvcml0eTEhMB8GCSqGSIb3DQEJ
+ARYSc3VwcG9ydEBjYWNlcnQub3JnMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
+CgKCAgEAziLA4kZ97DYoB1CW8qAzQIxL8TtmPzHlawI229Z89vGIj053NgVBlfkJ
+8BLPRoZzYLdufujAWGSuzbCtRRcMY/pnCujW0r8+55jE8Ez64AO7NV1sId6eINm6
+zWYyN3L69wj1x81YyY7nDl7qPv4coRQKFWyGhFtkZip6qUtTefWIonvuLwphK42y
+fk1WpRPs6tqSnqxEQR5YYGUFZvjARL3LlPdCfgv3ZWiYUQXw8wWRBB0bF4LsyFe7
+w2t6iPGwcswlWyCR7BYCEo8y6RcYSNDHBS4CMEK4JZwFaz+qOqfrU0j36NK2B5jc
+G8Y0f3/JHIJ6BVgrCFvzOKKrF11myZjXnhCLotLddJr3cQxyYN/Nb5gznZY0dj4k
+epKwDpUeb+agRThHqtdB7Uq3EvbXG4OKDy7YCbZZ16oE/9KTfWgu3YtLq1i6L43q
+laegw1SJpfvbi1EinbLDvhG+LJGGi5Z4rSDTii8aP8bQUWWHIbEZAWV/RRyH9XzQ
+QUxPKZgh/TMfdQwEUfoZd9vUFBzugcMd9Zi3aQaRIt0AUMyBMawSB3s42mhb5ivU
+fslfrejrckzzAeVLIL+aplfKkQABi6F1ITe1Yw1nPkZPcCBnzsXWWdsC4PDSy826
+YreQQejdIOQpvGQpQsgi3Hia/0PsmBsJUUtaWsJx8cTLc6nloQsCAwEAAaOCAc4w
+ggHKMB0GA1UdDgQWBBQWtTIb1Mfz4OaO873SsDrusjkY0TCBowYDVR0jBIGbMIGY
+gBQWtTIb1Mfz4OaO873SsDrusjkY0aF9pHsweTEQMA4GA1UEChMHUm9vdCBDQTEe
+MBwGA1UECxMVaHR0cDovL3d3dy5jYWNlcnQub3JnMSIwIAYDVQQDExlDQSBDZXJ0
+IFNpZ25pbmcgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJzdXBwb3J0QGNhY2Vy
+dC5vcmeCAQAwDwYDVR0TAQH/BAUwAwEB/zAyBgNVHR8EKzApMCegJaAjhiFodHRw
+czovL3d3dy5jYWNlcnQub3JnL3Jldm9rZS5jcmwwMAYJYIZIAYb4QgEEBCMWIWh0
+dHBzOi8vd3d3LmNhY2VydC5vcmcvcmV2b2tlLmNybDA0BglghkgBhvhCAQgEJxYl
+aHR0cDovL3d3dy5jYWNlcnQub3JnL2luZGV4LnBocD9pZD0xMDBWBglghkgBhvhC
+AQ0ESRZHVG8gZ2V0IHlvdXIgb3duIGNlcnRpZmljYXRlIGZvciBGUkVFIGhlYWQg
+b3ZlciB0byBodHRwOi8vd3d3LmNhY2VydC5vcmcwDQYJKoZIhvcNAQEEBQADggIB
+ACjH7pyCArpcgBLKNQodgW+JapnM8mgPf6fhjViVPr3yBsOQWqy1YPaZQwGjiHCc
+nWKdpIevZ1gNMDY75q1I08t0AoZxPuIrA2jxNGJARjtT6ij0rPtmlVOKTV39O9lg
+18p5aTuxZZKmxoGCXJzN600BiqXfEVWqFcofN8CCmHBh22p8lqOOLlQ+TyGpkO/c
+gr/c6EWtTZBzCDyUZbAEmXZ/4rzCahWqlwQ3JNgelE5tDlG+1sSPypZt90Pf6DBl
+Jzt7u0NDY8RD97LsaMzhGY4i+5jhe1o+ATc7iwiwovOVThrLm82asduycPAtStvY
+sONvRUgzEv/+PDIqVPfE94rwiCPCR/5kenHA0R6mY7AHfqQv0wGP3J8rtsYIqQ+T
+SCX8Ev2fQtzzxD72V7DX3WnRBnc0CkvSyqD/HMaMyRa+xMwyN2hzXwj7UfdJUzYF
+CpUCTPJ5GhD22Dp1nPMd8aINcGeGG7MW9S/lpOt5hvk9C8JzC6WZrG/8Z7jlLwum
+GCSNe9FINSkYQKyTYOGWhlC0elnYjyELn8+CkcY7v2vcB5G5l1YjqrZslMZIBjzk
+zk6q5PYvCdxTby78dOs6Y5nCpqyJvKeyRKANihDjbPIky/qbn3BHLt4Ui9SyIAmW
+omTxJBzcoTWcFbLUvFUufQb1nA5V9FrWk9p2rSVzTMVD
+-----END CERTIFICATE-----
diff -Naur a/Lib/test/capath-2048-plus/99d0fa06.0 b/Lib/test/capath-2048-plus/99d0fa06.0
--- a/Lib/test/capath-2048-plus/99d0fa06.0	1969-12-31 16:00:00.000000000 -0800
+++ b/Lib/test/capath-2048-plus/99d0fa06.0	2021-08-26 15:41:59.479194000 -0700
@@ -0,0 +1,41 @@
+-----BEGIN CERTIFICATE-----
+MIIHPTCCBSWgAwIBAgIBADANBgkqhkiG9w0BAQQFADB5MRAwDgYDVQQKEwdSb290
+IENBMR4wHAYDVQQLExVodHRwOi8vd3d3LmNhY2VydC5vcmcxIjAgBgNVBAMTGUNB
+IENlcnQgU2lnbmluZyBBdXRob3JpdHkxITAfBgkqhkiG9w0BCQEWEnN1cHBvcnRA
+Y2FjZXJ0Lm9yZzAeFw0wMzAzMzAxMjI5NDlaFw0zMzAzMjkxMjI5NDlaMHkxEDAO
+BgNVBAoTB1Jvb3QgQ0ExHjAcBgNVBAsTFWh0dHA6Ly93d3cuY2FjZXJ0Lm9yZzEi
+MCAGA1UEAxMZQ0EgQ2VydCBTaWduaW5nIEF1dGhvcml0eTEhMB8GCSqGSIb3DQEJ
+ARYSc3VwcG9ydEBjYWNlcnQub3JnMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIIC
+CgKCAgEAziLA4kZ97DYoB1CW8qAzQIxL8TtmPzHlawI229Z89vGIj053NgVBlfkJ
+8BLPRoZzYLdufujAWGSuzbCtRRcMY/pnCujW0r8+55jE8Ez64AO7NV1sId6eINm6
+zWYyN3L69wj1x81YyY7nDl7qPv4coRQKFWyGhFtkZip6qUtTefWIonvuLwphK42y
+fk1WpRPs6tqSnqxEQR5YYGUFZvjARL3LlPdCfgv3ZWiYUQXw8wWRBB0bF4LsyFe7
+w2t6iPGwcswlWyCR7BYCEo8y6RcYSNDHBS4CMEK4JZwFaz+qOqfrU0j36NK2B5jc
+G8Y0f3/JHIJ6BVgrCFvzOKKrF11myZjXnhCLotLddJr3cQxyYN/Nb5gznZY0dj4k
+epKwDpUeb+agRThHqtdB7Uq3EvbXG4OKDy7YCbZZ16oE/9KTfWgu3YtLq1i6L43q
+laegw1SJpfvbi1EinbLDvhG+LJGGi5Z4rSDTii8aP8bQUWWHIbEZAWV/RRyH9XzQ
+QUxPKZgh/TMfdQwEUfoZd9vUFBzugcMd9Zi3aQaRIt0AUMyBMawSB3s42mhb5ivU
+fslfrejrckzzAeVLIL+aplfKkQABi6F1ITe1Yw1nPkZPcCBnzsXWWdsC4PDSy826
+YreQQejdIOQpvGQpQsgi3Hia/0PsmBsJUUtaWsJx8cTLc6nloQsCAwEAAaOCAc4w
+ggHKMB0GA1UdDgQWBBQWtTIb1Mfz4OaO873SsDrusjkY0TCBowYDVR0jBIGbMIGY
+gBQWtTIb1Mfz4OaO873SsDrusjkY0aF9pHsweTEQMA4GA1UEChMHUm9vdCBDQTEe
+MBwGA1UECxMVaHR0cDovL3d3dy5jYWNlcnQub3JnMSIwIAYDVQQDExlDQSBDZXJ0
+IFNpZ25pbmcgQXV0aG9yaXR5MSEwHwYJKoZIhvcNAQkBFhJzdXBwb3J0QGNhY2Vy
+dC5vcmeCAQAwDwYDVR0TAQH/BAUwAwEB/zAyBgNVHR8EKzApMCegJaAjhiFodHRw
+czovL3d3dy5jYWNlcnQub3JnL3Jldm9rZS5jcmwwMAYJYIZIAYb4QgEEBCMWIWh0
+dHBzOi8vd3d3LmNhY2VydC5vcmcvcmV2b2tlLmNybDA0BglghkgBhvhCAQgEJxYl
+aHR0cDovL3d3dy5jYWNlcnQub3JnL2luZGV4LnBocD9pZD0xMDBWBglghkgBhvhC
+AQ0ESRZHVG8gZ2V0IHlvdXIgb3duIGNlcnRpZmljYXRlIGZvciBGUkVFIGhlYWQg
+b3ZlciB0byBodHRwOi8vd3d3LmNhY2VydC5vcmcwDQYJKoZIhvcNAQEEBQADggIB
+ACjH7pyCArpcgBLKNQodgW+JapnM8mgPf6fhjViVPr3yBsOQWqy1YPaZQwGjiHCc
+nWKdpIevZ1gNMDY75q1I08t0AoZxPuIrA2jxNGJARjtT6ij0rPtmlVOKTV39O9lg
+18p5aTuxZZKmxoGCXJzN600BiqXfEVWqFcofN8CCmHBh22p8lqOOLlQ+TyGpkO/c
+gr/c6EWtTZBzCDyUZbAEmXZ/4rzCahWqlwQ3JNgelE5tDlG+1sSPypZt90Pf6DBl
+Jzt7u0NDY8RD97LsaMzhGY4i+5jhe1o+ATc7iwiwovOVThrLm82asduycPAtStvY
+sONvRUgzEv/+PDIqVPfE94rwiCPCR/5kenHA0R6mY7AHfqQv0wGP3J8rtsYIqQ+T
+SCX8Ev2fQtzzxD72V7DX3WnRBnc0CkvSyqD/HMaMyRa+xMwyN2hzXwj7UfdJUzYF
+CpUCTPJ5GhD22Dp1nPMd8aINcGeGG7MW9S/lpOt5hvk9C8JzC6WZrG/8Z7jlLwum
+GCSNe9FINSkYQKyTYOGWhlC0elnYjyELn8+CkcY7v2vcB5G5l1YjqrZslMZIBjzk
+zk6q5PYvCdxTby78dOs6Y5nCpqyJvKeyRKANihDjbPIky/qbn3BHLt4Ui9SyIAmW
+omTxJBzcoTWcFbLUvFUufQb1nA5V9FrWk9p2rSVzTMVD
+-----END CERTIFICATE-----
diff -Naur a/Lib/test/capath-2048-plus/b1930218.0 b/Lib/test/capath-2048-plus/b1930218.0
--- a/Lib/test/capath-2048-plus/b1930218.0	1969-12-31 16:00:00.000000000 -0800
+++ b/Lib/test/capath-2048-plus/b1930218.0	2021-08-26 15:41:59.479646000 -0700
@@ -0,0 +1,26 @@
+-----BEGIN CERTIFICATE-----
+MIIEbTCCAtWgAwIBAgIJAMstgJlaaVJbMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNV
+BAYTAlhZMSYwJAYDVQQKDB1QeXRob24gU29mdHdhcmUgRm91bmRhdGlvbiBDQTEW
+MBQGA1UEAwwNb3VyLWNhLXNlcnZlcjAeFw0xODA4MjkxNDIzMTZaFw0yODA4MjYx
+NDIzMTZaME0xCzAJBgNVBAYTAlhZMSYwJAYDVQQKDB1QeXRob24gU29mdHdhcmUg
+Rm91bmRhdGlvbiBDQTEWMBQGA1UEAwwNb3VyLWNhLXNlcnZlcjCCAaIwDQYJKoZI
+hvcNAQEBBQADggGPADCCAYoCggGBAJftVUG6NheV23Ec0+FhrFhz48aWzysfuAj1
+nUtLxzD2uAuzUnKgu8lNO47fIo4BV4HJknPMAMbscLA6F0DB3/KMNkzEp4HntiRo
+4qB+NQcvoFv5RUb3HvBGEf7KGjxQ8SapX5winPhB4d9PEpUZL1yQARdufj59z+kJ
+ryX4+EJ3LW1fNvJ4Hn1Kh2hjbAZxG436Jf7U0/WlF7Hv6hfLVMgnmYDLPEXxLFIc
+3R9RRSBQHl6rV3MbQXiW3oSket2PMIU2WHl2oNJhyBuplJljxu74FL+0UlYxl/rr
+rFOelc5MxFpKt8oDJ1s1V84C3OzKafiKWjnLFiAVAyRhbPR6/LZI5VkQXEnQI5/7
+cV466WifNHKAJ7Y/TLHZ22N/Z2hKbhH46MD0WhY5Uwto3nf6Ref4kc14zSiUl3FU
++8/wN97JJsXcG56JbQmsyERxy23xlzHVTCAzv3VKoODcaRHtKrRkEBEwiw6wpxDY
+isWqG8gmiiXnZp+lahovfF+DxnhPHwIDAQABo1AwTjAdBgNVHQ4EFgQU3b/K2ubR
+NLo3dSHKb5oIKPI1tkgwHwYDVR0jBBgwFoAU3b/K2ubRNLo3dSHKb5oIKPI1tkgw
+DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAYEAM2pU02vA1wFfnfQFwZNm
+kFDQtxjpsB5KoLbadpOvhNutFVQxFRPk3n5ODNUJHDQ1tuVM1m9lfTJf6/ypawf3
+SYLlgX4HgJpj+CzDQLyP1CraPtHuCLdNp4TK9D+hmEW+sQVp59/Xmasb7oswzPf8
+59QLF66Xv+R7/Q+ntIV541niFoe/HylFLCOTdr7Ahx3e7CtCauW7yPQKSggKjFzY
+fU3RuL/V9yntktGUBOg1Bld/LCOXh6U1jSbTGkfyFtfZxtQfI0PTJpk5yiD0cSNv
+DEp2dvd2H7P+v0ew/CpWgeHS3e4I2PT/WtwlYYqRArmGHPJQc3YlNfy2JSYVy+vE
+K2EMHOfuLxeb7PDUoYTn0q/e5BskFKcBh+OrKVhGoNnACuCN11nTG/hUID54paXI
+T4sDxJaf7PtHz3YtjWU0J7/6rgEFivOSCt2JbJehx+dgUees60t9LLhlyf5dakhV
+juTH+WpA4bhkRem1WSmlX899WH1keeWkCawedmU9lMRo
+-----END CERTIFICATE-----
diff -Naur a/Lib/test/capath-2048-plus/ceff1710.0 b/Lib/test/capath-2048-plus/ceff1710.0
--- a/Lib/test/capath-2048-plus/ceff1710.0	1969-12-31 16:00:00.000000000 -0800
+++ b/Lib/test/capath-2048-plus/ceff1710.0	2021-08-26 15:41:59.480215000 -0700
@@ -0,0 +1,26 @@
+-----BEGIN CERTIFICATE-----
+MIIEbTCCAtWgAwIBAgIJAMstgJlaaVJbMA0GCSqGSIb3DQEBCwUAME0xCzAJBgNV
+BAYTAlhZMSYwJAYDVQQKDB1QeXRob24gU29mdHdhcmUgRm91bmRhdGlvbiBDQTEW
+MBQGA1UEAwwNb3VyLWNhLXNlcnZlcjAeFw0xODA4MjkxNDIzMTZaFw0yODA4MjYx
+NDIzMTZaME0xCzAJBgNVBAYTAlhZMSYwJAYDVQQKDB1QeXRob24gU29mdHdhcmUg
+Rm91bmRhdGlvbiBDQTEWMBQGA1UEAwwNb3VyLWNhLXNlcnZlcjCCAaIwDQYJKoZI
+hvcNAQEBBQADggGPADCCAYoCggGBAJftVUG6NheV23Ec0+FhrFhz48aWzysfuAj1
+nUtLxzD2uAuzUnKgu8lNO47fIo4BV4HJknPMAMbscLA6F0DB3/KMNkzEp4HntiRo
+4qB+NQcvoFv5RUb3HvBGEf7KGjxQ8SapX5winPhB4d9PEpUZL1yQARdufj59z+kJ
+ryX4+EJ3LW1fNvJ4Hn1Kh2hjbAZxG436Jf7U0/WlF7Hv6hfLVMgnmYDLPEXxLFIc
+3R9RRSBQHl6rV3MbQXiW3oSket2PMIU2WHl2oNJhyBuplJljxu74FL+0UlYxl/rr
+rFOelc5MxFpKt8oDJ1s1V84C3OzKafiKWjnLFiAVAyRhbPR6/LZI5VkQXEnQI5/7
+cV466WifNHKAJ7Y/TLHZ22N/Z2hKbhH46MD0WhY5Uwto3nf6Ref4kc14zSiUl3FU
++8/wN97JJsXcG56JbQmsyERxy23xlzHVTCAzv3VKoODcaRHtKrRkEBEwiw6wpxDY
+isWqG8gmiiXnZp+lahovfF+DxnhPHwIDAQABo1AwTjAdBgNVHQ4EFgQU3b/K2ubR
+NLo3dSHKb5oIKPI1tkgwHwYDVR0jBBgwFoAU3b/K2ubRNLo3dSHKb5oIKPI1tkgw
+DAYDVR0TBAUwAwEB/zANBgkqhkiG9w0BAQsFAAOCAYEAM2pU02vA1wFfnfQFwZNm
+kFDQtxjpsB5KoLbadpOvhNutFVQxFRPk3n5ODNUJHDQ1tuVM1m9lfTJf6/ypawf3
+SYLlgX4HgJpj+CzDQLyP1CraPtHuCLdNp4TK9D+hmEW+sQVp59/Xmasb7oswzPf8
+59QLF66Xv+R7/Q+ntIV541niFoe/HylFLCOTdr7Ahx3e7CtCauW7yPQKSggKjFzY
+fU3RuL/V9yntktGUBOg1Bld/LCOXh6U1jSbTGkfyFtfZxtQfI0PTJpk5yiD0cSNv
+DEp2dvd2H7P+v0ew/CpWgeHS3e4I2PT/WtwlYYqRArmGHPJQc3YlNfy2JSYVy+vE
+K2EMHOfuLxeb7PDUoYTn0q/e5BskFKcBh+OrKVhGoNnACuCN11nTG/hUID54paXI
+T4sDxJaf7PtHz3YtjWU0J7/6rgEFivOSCt2JbJehx+dgUees60t9LLhlyf5dakhV
+juTH+WpA4bhkRem1WSmlX899WH1keeWkCawedmU9lMRo
+-----END CERTIFICATE-----
diff -Naur a/Lib/test/support/__init__.py b/Lib/test/support/__init__.py
--- a/Lib/test/support/__init__.py	2021-09-16 08:35:22.622315090 -0700
+++ b/Lib/test/support/__init__.py	2021-08-26 15:42:00.737563000 -0700
@@ -818,7 +818,8 @@
         try:
             f(*args, **kwargs)
         except OSError as e:
-            if "CERTIFICATE_VERIFY_FAILED" in str(e):
+            if ("CERTIFICATE_VERIFY_FAILED" in str(e)) or \
+               ("ASN no signer error" in str(e)):
                 raise unittest.SkipTest("system does not contain "
                                         "necessary certificates")
             raise
diff -Naur a/Lib/test/test_ssl.py b/Lib/test/test_ssl.py
--- a/Lib/test/test_ssl.py	2021-09-16 08:35:22.578316802 -0700
+++ b/Lib/test/test_ssl.py	2021-09-16 01:20:16.708824005 -0700
@@ -66,9 +66,17 @@
 CERTFILE_PROTECTED = data_file("keycert.passwd.pem")
 ONLYKEY_PROTECTED = data_file("ssl_key.passwd.pem")
 KEY_PASSWORD = "somepass"
-CAPATH = data_file("capath")
+
+# for FIPS and wolfSSL there is a minumum RSA size, use 2048 bits and higher
+if ssl.IS_WOLFSSL:
+    # Substitute alternate CA. neuronio CA is RSA 512, which is below
+    # wolfSSL's default minimum allowed RSA key size
+    CAFILE_NEURONIO = data_file("capath", "b1930218.0")
+    CAPATH = data_file("capath-2048-plus")
+else:
+    CAFILE_NEURONIO = data_file("capath", "4e1295a3.0")
+    CAPATH = data_file("capath")
 BYTES_CAPATH = os.fsencode(CAPATH)
-CAFILE_NEURONIO = data_file("capath", "4e1295a3.0")
 CAFILE_CACERT = data_file("capath", "5ed36f99.0")
 
 CERTFILE_INFO = {
@@ -112,6 +120,23 @@
     'version': 3
 }
 
+# slightly different order of info @TODO no OCSP and caIssuers yet
+WOLFSSL_SIGNED_CERTFILE_INFO = {
+    'subject': ((('countryName', 'XY'),),
+             (('localityName', 'Castle Anthrax'),),
+             (('organizationName', 'Python Software Foundation'),),
+             (('commonName', 'localhost'),)),
+    'issuer': ((('countryName', 'XY'),),
+            (('organizationName', 'Python Software Foundation CA'),),
+            (('commonName', 'our-ca-server'),)),
+    'version': 3,
+    'serialNumber': 'CB2D80995A69525C',
+    'notBefore': 'Aug 29 14:23:16 2018 GMT',
+    'notAfter': 'Jul  7 14:23:16 2028 GMT',
+    'subjectAltName': (('DNS', 'localhost'),),
+    'crlDistributionPoints': ('http://testca.pythontest.net/testca/revocation.crl',),
+}
+
 SIGNED_CERTFILE2 = data_file("keycert4.pem")
 SIGNED_CERTFILE2_HOSTNAME = 'fakehostname'
 SIGNED_CERTFILE_ECC = data_file("keycertecc.pem")
@@ -425,10 +450,17 @@
             ssl._ssl._test_decode_cert(CERTFILE),
             CERTFILE_INFO
         )
-        self.assertEqual(
-            ssl._ssl._test_decode_cert(SIGNED_CERTFILE),
-            SIGNED_CERTFILE_INFO
-        )
+
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(
+                ssl._ssl._test_decode_cert(SIGNED_CERTFILE),
+                WOLFSSL_SIGNED_CERTFILE_INFO
+            )
+        else:
+            self.assertEqual(
+                ssl._ssl._test_decode_cert(SIGNED_CERTFILE),
+                SIGNED_CERTFILE_INFO
+            )
 
         # Issue #13034: the subjectAltName in some certificates
         # (notably projects.developer.nokia.com:443) wasn't parsed
@@ -440,10 +472,15 @@
                           ('DNS', 'projects.forum.nokia.com'))
                         )
         # extra OCSP and AIA fields
-        self.assertEqual(p['OCSP'], ('http://ocsp.verisign.com',))
-        self.assertEqual(p['caIssuers'],
+        if ssl.IS_WOLFSSL:
+            #@TODO OCSP and caIssuers parsing from wolfSSL
+            self.assertEqual(p['crlDistributionPoints'],
+                         ('http://SVRIntl-G3-crl.verisign.com/SVRIntlG3.crl',))
+        else:
+            self.assertEqual(p['OCSP'], ('http://ocsp.verisign.com',))
+            self.assertEqual(p['caIssuers'],
                          ('http://SVRIntl-G3-aia.verisign.com/SVRIntlG3.cer',))
-        self.assertEqual(p['crlDistributionPoints'],
+            self.assertEqual(p['crlDistributionPoints'],
                          ('http://SVRIntl-G3-crl.verisign.com/SVRIntlG3.crl',))
 
     def test_parse_cert_CVE_2019_5010(self):
@@ -480,7 +517,14 @@
                    (('emailAddress', 'python-dev@python.org'),))
         self.assertEqual(p['subject'], subject)
         self.assertEqual(p['issuer'], subject)
-        if ssl._OPENSSL_API_VERSION >= (0, 9, 8):
+        if ssl.IS_WOLFSSL:
+            # location of email in list is different
+            san = (('DNS', 'altnull.python.org\x00example.com'),
+                   ('URI', 'http://null.python.org\x00http://example.org'),
+                   ('IP Address', '192.0.2.1'),
+                   ('IP Address', '2001:DB8:0:0:0:0:0:1'),
+                   ('email', 'null@python.org\x00user@example.org'))
+        elif ssl._OPENSSL_API_VERSION >= (0, 9, 8):
             san = (('DNS', 'altnull.python.org\x00example.com'),
                    ('email', 'null@python.org\x00user@example.org'),
                    ('URI', 'http://null.python.org\x00http://example.org'),
@@ -498,7 +542,26 @@
 
     def test_parse_all_sans(self):
         p = ssl._ssl._test_decode_cert(ALLSANFILE)
-        self.assertEqual(p['subjectAltName'],
+        if ssl.IS_WOLFSSL:
+            # wolfSSL currently skips over othername, does not have RID and has
+            # a slightly different order of how the entries are listed in struct
+            self.assertEqual(p['subjectAltName'],
+            (
+                ('DNS', 'allsans'),
+                ('DNS', 'www.example.org'),
+                ('URI', 'https://www.python.org/'),
+                ('IP Address', '127.0.0.1'),
+                ('IP Address', '0:0:0:0:0:0:0:1'),
+                ('email', 'user@example.org'),
+                ('DirName',
+                    ((('countryName', 'XY'),),
+                    (('localityName', 'Castle Anthrax'),),
+                    (('organizationName', 'Python Software Foundation'),),
+                    (('commonName', 'dirname example'),)))
+            )
+            )
+        else:
+            self.assertEqual(p['subjectAltName'],
             (
                 ('DNS', 'allsans'),
                 ('othername', '<unsupported>'),
@@ -515,7 +578,7 @@
                 ('IP Address', '0:0:0:0:0:0:0:1'),
                 ('Registered ID', '1.2.3.4.5')
             )
-        )
+            )
 
     def test_DER_to_PEM(self):
         with open(CAFILE_CACERT, 'r') as f:
@@ -556,6 +619,8 @@
         if IS_LIBRESSL:
             self.assertTrue(s.startswith("LibreSSL {:d}".format(major)),
                             (s, t, hex(n)))
+        elif ssl.IS_WOLFSSL:
+            self.assertTrue(s.startswith("wolfSSL".format(major)), (s, t, hex(n)))
         else:
             self.assertTrue(s.startswith("OpenSSL {:d}.{:d}.{:d}".format(major, minor, fix)),
                             (s, t, hex(n)))
@@ -884,6 +949,7 @@
             support.gc_collect()
         self.assertIn(r, str(cm.warning.args[0]))
 
+    @unittest.skipIf(ssl.IS_WOLFSSL, "wolfSSL does not support default verify paths")
     def test_get_default_verify_paths(self):
         paths = ssl.get_default_verify_paths()
         self.assertEqual(len(paths), 6)
@@ -937,35 +1003,50 @@
 
 
     def test_asn1object(self):
-        expected = (129, 'serverAuth', 'TLS Web Server Authentication',
-                    '1.3.6.1.5.5.7.3.1')
-
+        if ssl.IS_WOLFSSL:
+            expected = (71, 'serverAuth', 'TLS Web Server Authentication',
+                        '1.3.6.1.5.5.7.3.1')
+        else:
+            expected = (129, 'serverAuth', 'TLS Web Server Authentication',
+                        '1.3.6.1.5.5.7.3.1')
+        
         val = ssl._ASN1Object('1.3.6.1.5.5.7.3.1')
         self.assertEqual(val, expected)
-        self.assertEqual(val.nid, 129)
+        
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(val.nid, 71)
+        else:
+            self.assertEqual(val.nid, 129)
+        
         self.assertEqual(val.shortname, 'serverAuth')
         self.assertEqual(val.longname, 'TLS Web Server Authentication')
         self.assertEqual(val.oid, '1.3.6.1.5.5.7.3.1')
         self.assertIsInstance(val, ssl._ASN1Object)
         self.assertRaises(ValueError, ssl._ASN1Object, 'serverAuth')
-
-        val = ssl._ASN1Object.fromnid(129)
+        if ssl.IS_WOLFSSL:
+            val = ssl._ASN1Object.fromnid(71)
+        else:
+            val = ssl._ASN1Object.fromnid(129)
         self.assertEqual(val, expected)
+        
         self.assertIsInstance(val, ssl._ASN1Object)
         self.assertRaises(ValueError, ssl._ASN1Object.fromnid, -1)
         with self.assertRaisesRegex(ValueError, "unknown NID 100000"):
             ssl._ASN1Object.fromnid(100000)
-        for i in range(1000):
-            try:
-                obj = ssl._ASN1Object.fromnid(i)
-            except ValueError:
-                pass
-            else:
-                self.assertIsInstance(obj.nid, int)
-                self.assertIsInstance(obj.shortname, str)
-                self.assertIsInstance(obj.longname, str)
-                self.assertIsInstance(obj.oid, (str, type(None)))
-
+        
+        if not ssl.IS_WOLFSSL:
+            for i in range(1000):
+                try:
+                    print(i)
+                    obj = ssl._ASN1Object.fromnid(i)
+                except ValueError:
+                    pass
+                else:
+                    self.assertIsInstance(obj.nid, int)
+                    self.assertIsInstance(obj.shortname, str)
+                    self.assertIsInstance(obj.longname, str)
+                    self.assertIsInstance(obj.oid, (str, type(None)))
+        
         val = ssl._ASN1Object.fromname('TLS Web Server Authentication')
         self.assertEqual(val, expected)
         self.assertIsInstance(val, ssl._ASN1Object)
@@ -979,7 +1060,10 @@
         val = ssl._ASN1Object('1.3.6.1.5.5.7.3.1')
         self.assertIsInstance(ssl.Purpose.SERVER_AUTH, ssl._ASN1Object)
         self.assertEqual(ssl.Purpose.SERVER_AUTH, val)
-        self.assertEqual(ssl.Purpose.SERVER_AUTH.nid, 129)
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(ssl.Purpose.SERVER_AUTH.nid, 71)
+        else:
+            self.assertEqual(ssl.Purpose.SERVER_AUTH.nid, 129)
         self.assertEqual(ssl.Purpose.SERVER_AUTH.shortname, 'serverAuth')
         self.assertEqual(ssl.Purpose.SERVER_AUTH.oid,
                               '1.3.6.1.5.5.7.3.1')
@@ -987,7 +1071,10 @@
         val = ssl._ASN1Object('1.3.6.1.5.5.7.3.2')
         self.assertIsInstance(ssl.Purpose.CLIENT_AUTH, ssl._ASN1Object)
         self.assertEqual(ssl.Purpose.CLIENT_AUTH, val)
-        self.assertEqual(ssl.Purpose.CLIENT_AUTH.nid, 130)
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(ssl.Purpose.CLIENT_AUTH.nid, 72)
+        else:
+            self.assertEqual(ssl.Purpose.CLIENT_AUTH.nid, 130)
         self.assertEqual(ssl.Purpose.CLIENT_AUTH.shortname, 'clientAuth')
         self.assertEqual(ssl.Purpose.CLIENT_AUTH.oid,
                               '1.3.6.1.5.5.7.3.2')
@@ -1121,6 +1208,7 @@
             self.assertNotIn("3DES", name)
 
     @unittest.skipIf(ssl.OPENSSL_VERSION_INFO < (1, 0, 2, 0, 0), 'OpenSSL too old')
+    @unittest.skipIf(ssl.IS_WOLFSSL, 'AESGCM cipher string not supported by wolfSSL')
     def test_get_ciphers(self):
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
         ctx.set_ciphers('AESGCM')
@@ -1203,7 +1291,7 @@
         maximum_range = {
             # stock OpenSSL
             ssl.TLSVersion.MAXIMUM_SUPPORTED,
-            # Fedora 32 uses TLS 1.3 by default
+            # Fedora 32 and wolfSSL uses TLS 1.3 by default
             ssl.TLSVersion.TLSv1_3
         }
 
@@ -1257,9 +1345,17 @@
         self.assertIn(
             ctx.minimum_version, minimum_range
         )
-        self.assertEqual(
-            ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED
-        )
+
+        if not ssl.IS_WOLFSSL:
+            self.assertEqual(
+                ctx.maximum_version, ssl.TLSVersion.MAXIMUM_SUPPORTED
+            )
+        else:
+            # wolfSSL default max is set to the max protocol, i.e TLS 1.3
+            self.assertIn(
+                ctx.maximum_version, maximum_range
+            )
+
         with self.assertRaises(ValueError):
             ctx.minimum_version = ssl.TLSVersion.MINIMUM_SUPPORTED
         with self.assertRaises(ValueError):
@@ -1279,10 +1375,11 @@
         self.assertEqual(ctx.verify_flags, ssl.VERIFY_CRL_CHECK_CHAIN)
         ctx.verify_flags = ssl.VERIFY_DEFAULT
         self.assertEqual(ctx.verify_flags, ssl.VERIFY_DEFAULT)
-        # supports any value
-        ctx.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT
-        self.assertEqual(ctx.verify_flags,
-                         ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT)
+        if not ssl.IS_WOLFSSL:
+            # supports any value
+            ctx.verify_flags = ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT
+            self.assertEqual(ctx.verify_flags,
+                            ssl.VERIFY_CRL_CHECK_LEAF | ssl.VERIFY_X509_STRICT)
         with self.assertRaises(TypeError):
             ctx.verify_flags = None
 
@@ -1295,25 +1392,50 @@
         with self.assertRaises(OSError) as cm:
             ctx.load_cert_chain(NONEXISTINGCERT)
         self.assertEqual(cm.exception.errno, errno.ENOENT)
-        with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
-            ctx.load_cert_chain(BADCERT)
-        with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
-            ctx.load_cert_chain(EMPTYCERT)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "Buffer error"):
+                ctx.load_cert_chain(BADCERT)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
+                ctx.load_cert_chain(BADCERT)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "unknown error"):
+                ctx.load_cert_chain(EMPTYCERT)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
+                ctx.load_cert_chain(EMPTYCERT)
+        
         # Separate key and cert
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
         ctx.load_cert_chain(ONLYCERT, ONLYKEY)
         ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)
         ctx.load_cert_chain(certfile=BYTES_ONLYCERT, keyfile=BYTES_ONLYKEY)
-        with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
-            ctx.load_cert_chain(ONLYCERT)
-        with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
-            ctx.load_cert_chain(ONLYKEY)
-        with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
-            ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "unknown"):
+                ctx.load_cert_chain(ONLYCERT)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
+                ctx.load_cert_chain(ONLYCERT)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "unknown"):
+                ctx.load_cert_chain(ONLYKEY)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
+                ctx.load_cert_chain(ONLYKEY)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "unknown"):
+                ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
+                ctx.load_cert_chain(certfile=ONLYKEY, keyfile=ONLYCERT)
         # Mismatching key and cert
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
-        with self.assertRaisesRegex(ssl.SSLError, "key values mismatch"):
-            ctx.load_cert_chain(CAFILE_CACERT, ONLYKEY)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "unknow"):
+                ctx.load_cert_chain(CAFILE_CACERT, ONLYKEY)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "key values mismatch"):
+                ctx.load_cert_chain(CAFILE_CACERT, ONLYKEY)
         # Password protected key and cert
         ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD)
         ctx.load_cert_chain(CERTFILE_PROTECTED, password=KEY_PASSWORD.encode())
@@ -1380,8 +1502,13 @@
         with self.assertRaises(OSError) as cm:
             ctx.load_verify_locations(NONEXISTINGCERT)
         self.assertEqual(cm.exception.errno, errno.ENOENT)
-        with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
-            ctx.load_verify_locations(BADCERT)
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "Buffer error"):
+                ctx.load_verify_locations(BADCERT)
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "PEM lib"):
+                ctx.load_verify_locations(BADCERT)
+        
         ctx.load_verify_locations(CERTFILE, CAPATH)
         ctx.load_verify_locations(CERTFILE, capath=BYTES_CAPATH)
 
@@ -1422,28 +1549,38 @@
         self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
 
         # test DER
-        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
-        ctx.load_verify_locations(cadata=cacert_der)
-        ctx.load_verify_locations(cadata=neuronio_der)
-        self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
-        # cert already in hash table
-        ctx.load_verify_locations(cadata=cacert_der)
-        self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
-
-        # combined
-        ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
-        combined = b"".join((cacert_der, neuronio_der))
-        ctx.load_verify_locations(cadata=combined)
-        self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
+        # wolfSSL_CTX_load_verify_locations() works with PEM
+        if not ssl.IS_WOLFSSL:
+            ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
+            ctx.load_verify_locations(cadata=cacert_der)
+            ctx.load_verify_locations(cadata=neuronio_der)
+            self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
+            # cert already in hash table
+            ctx.load_verify_locations(cadata=cacert_der)
+            self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
+
+            # combined
+            ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
+            combined = b"".join((cacert_der, neuronio_der))
+            ctx.load_verify_locations(cadata=combined)
+            self.assertEqual(ctx.cert_store_stats()["x509_ca"], 2)
 
         # error cases
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
         self.assertRaises(TypeError, ctx.load_verify_locations, cadata=object)
 
-        with self.assertRaisesRegex(ssl.SSLError, "no start line"):
-            ctx.load_verify_locations(cadata="broken")
-        with self.assertRaisesRegex(ssl.SSLError, "not enough data"):
-            ctx.load_verify_locations(cadata=b"broken")
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "NO_START_LINE"):
+                ctx.load_verify_locations(cadata="broken")
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "no start line"):
+                ctx.load_verify_locations(cadata="broken")
+        if ssl.IS_WOLFSSL:
+            with self.assertRaisesRegex(ssl.SSLError, "unknown error"):
+                ctx.load_verify_locations(cadata=b"broken")
+        else:
+            with self.assertRaisesRegex(ssl.SSLError, "not enough data"):
+                ctx.load_verify_locations(cadata=b"broken")
 
 
     def test_load_dh_params(self):
@@ -1579,6 +1716,7 @@
 
     @unittest.skipIf(sys.platform == "win32", "not-Windows specific")
     @unittest.skipIf(IS_LIBRESSL, "LibreSSL doesn't support env vars")
+    @unittest.skipIf(ssl.IS_WOLFSSL, "wolfSSL doesn't support env vars")
     def test_load_default_certs_env(self):
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
         with support.EnvironmentVarGuard() as env:
@@ -1725,6 +1863,10 @@
             pass
 
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
+        if ssl.IS_WOLFSSL:
+            # requires loading CERT and KEY in advance
+            ctx.load_cert_chain(CERTFILE, keyfile=CERTFILE)
+        
         ctx.sslsocket_class = MySSLSocket
         ctx.sslobject_class = MySSLObject
 
@@ -1736,7 +1878,11 @@
     @unittest.skipUnless(IS_OPENSSL_1_1_1, "Test requires OpenSSL 1.1.1")
     def test_num_tickest(self):
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
-        self.assertEqual(ctx.num_tickets, 2)
+        # wolfSSL num_tickets default is 1, not 2 like OpenSSL
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(ctx.num_tickets, 1)
+        else:
+            self.assertEqual(ctx.num_tickets, 2)
         ctx.num_tickets = 1
         self.assertEqual(ctx.num_tickets, 1)
         ctx.num_tickets = 0
@@ -1747,7 +1893,10 @@
             ctx.num_tickets = None
 
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
-        self.assertEqual(ctx.num_tickets, 2)
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(ctx.num_tickets, 1)
+        else:
+            self.assertEqual(ctx.num_tickets, 2)
         with self.assertRaises(ValueError):
             ctx.num_tickets = 1
 
@@ -1772,7 +1921,10 @@
         self.assertEqual(cm.exception.library, 'PEM')
         self.assertEqual(cm.exception.reason, 'NO_START_LINE')
         s = str(cm.exception)
-        self.assertTrue(s.startswith("[PEM: NO_START_LINE] no start line"), s)
+        if ssl.IS_WOLFSSL:
+            self.assertTrue(s.startswith("[PEM: NO_START_LINE] unknown error number"), s)
+        else:
+            self.assertTrue(s.startswith("[PEM: NO_START_LINE] no start line"), s)
 
     def test_subclass(self):
         # Check that the appropriate SSLError subclass is raised
@@ -1874,6 +2026,7 @@
         with self.assertRaisesRegex(TypeError, "public constructor"):
             ssl.SSLObject(bio, bio)
 
+    @unittest.skipIf(ssl.IS_WOLFSSL, "read ahead restriction with shutdown needs implementation")
     def test_unwrap(self):
         client_ctx, server_ctx, hostname = testing_context()
         c_in = ssl.MemoryBIO()
@@ -1947,8 +2100,12 @@
         s = test_wrap_socket(socket.socket(socket.AF_INET),
                             cert_reqs=ssl.CERT_REQUIRED)
         self.addCleanup(s.close)
-        self.assertRaisesRegex(ssl.SSLError, "certificate verify failed",
-                               s.connect, self.server_addr)
+        if ssl.IS_WOLFSSL:
+            self.assertRaisesRegex(ssl.SSLError, "ASN no signer error to confirm failure",
+                                s.connect, self.server_addr)
+        else:
+            self.assertRaisesRegex(ssl.SSLError, "certificate verify failed",
+                                s.connect, self.server_addr)
 
     def test_connect_ex(self):
         # Issue #11326: check connect_ex() implementation
@@ -2011,7 +2168,11 @@
         ctx.verify_mode = ssl.CERT_REQUIRED
         s = ctx.wrap_socket(socket.socket(socket.AF_INET))
         self.addCleanup(s.close)
-        self.assertRaisesRegex(ssl.SSLError, "certificate verify failed",
+        if ssl.IS_WOLFSSL:
+            self.assertRaisesRegex(ssl.SSLError, "ASN no signer error to confirm failure",
+                                s.connect, self.server_addr)
+        else:
+            self.assertRaisesRegex(ssl.SSLError, "certificate verify failed",
                                 s.connect, self.server_addr)
 
     def test_connect_capath(self):
@@ -2124,13 +2285,19 @@
         # capath certs are loaded on request
         ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
         ctx.load_verify_locations(capath=CAPATH)
-        self.assertEqual(ctx.get_ca_certs(), [])
+        # @TODO wolfSSL will load in the certificates on set
+        if not ssl.IS_WOLFSSL:
+            self.assertEqual(ctx.get_ca_certs(), [])
         with ctx.wrap_socket(socket.socket(socket.AF_INET),
                              server_hostname='localhost') as s:
             s.connect(self.server_addr)
             cert = s.getpeercert()
             self.assertTrue(cert)
-        self.assertEqual(len(ctx.get_ca_certs()), 1)
+        if ssl.IS_WOLFSSL:
+            # all certificates, not just requested ones, are loaded
+            self.assertEqual(len(ctx.get_ca_certs()), 2)
+        else:
+            self.assertEqual(len(ctx.get_ca_certs()), 1)
 
     @needs_sni
     def test_context_setget(self):
@@ -2198,8 +2365,12 @@
         sslobj = ctx.wrap_bio(incoming, outgoing, False,
                               SIGNED_CERTFILE_HOSTNAME)
         self.assertIs(sslobj._sslobj.owner, sslobj)
-        self.assertIsNone(sslobj.cipher())
-        self.assertIsNone(sslobj.version())
+
+        # @TODO wolfSSL is listing a protocol version of TLS1.3 here
+        if not ssl.IS_WOLFSSL:
+            self.assertIsNone(sslobj.cipher())
+            self.assertIsNone(sslobj.version())
+
         self.assertIsNotNone(sslobj.shared_ciphers())
         self.assertRaises(ValueError, sslobj.getpeercert)
         if 'tls-unique' in ssl.CHANNEL_BINDING_TYPES:
@@ -2217,7 +2388,10 @@
             # If the server shuts down the TCP connection without sending a
             # secure shutdown message, this is reported as SSL_ERROR_SYSCALL
             pass
-        self.assertRaises(ssl.SSLError, sslobj.write, b'foo')
+
+        # @TODO wolfSSL not rasing an alert here
+        if not ssl.IS_WOLFSSL:
+            self.assertRaises(ssl.SSLError, sslobj.write, b'foo')
 
     def test_bio_read_write_data(self):
         sock = socket.socket(socket.AF_INET)
@@ -2831,23 +3005,30 @@
                                    server_context=client_context,
                                    chatty=True, connectionchatty=True,
                                    sni_name=hostname)
-            self.assertIn('called a function you should not call',
-                          str(e.exception))
-
-        with self.subTest(client=ssl.PROTOCOL_TLS_SERVER, server=ssl.PROTOCOL_TLS_SERVER):
-            with self.assertRaises(ssl.SSLError) as e:
-                server_params_test(client_context=server_context,
-                                   server_context=server_context,
-                                   chatty=True, connectionchatty=True)
-            self.assertIn('called a function you should not call',
-                          str(e.exception))
+            if ssl.IS_WOLFSSL:
+                self.assertIn('error state on socket', str(e.exception))
+            else:
+                self.assertIn('called a function you should not call',
+                              str(e.exception))
 
+        if not ssl.IS_WOLFSSL:
+            with self.subTest(client=ssl.PROTOCOL_TLS_SERVER, server=ssl.PROTOCOL_TLS_SERVER):
+                with self.assertRaises(ssl.SSLError) as e:
+                    server_params_test(client_context=server_context,
+                                      server_context=server_context,
+                                      chatty=True, connectionchatty=True)
+                    self.assertIn('called a function you should not call',
+                                str(e.exception))
+        
         with self.subTest(client=ssl.PROTOCOL_TLS_CLIENT, server=ssl.PROTOCOL_TLS_CLIENT):
             with self.assertRaises(ssl.SSLError) as e:
                 server_params_test(client_context=server_context,
                                    server_context=client_context,
                                    chatty=True, connectionchatty=True)
-            self.assertIn('called a function you should not call',
+            if ssl.IS_WOLFSSL:
+                self.assertIn('error state on socket', str(e.exception))
+            else:
+                self.assertIn('called a function you should not call',
                           str(e.exception))
 
     def test_getpeercert(self):
@@ -2888,6 +3069,7 @@
 
     @unittest.skipUnless(have_verify_flags(),
                         "verify_flags need OpenSSL > 0.9.8")
+    @unittest.skipIf(ssl.IS_WOLFSSL, "wolfSSL needs to call EnableCRL")
     def test_crl_check(self):
         if support.verbose:
             sys.stdout.write("\n")
@@ -2948,10 +3130,16 @@
         with server:
             with client_context.wrap_socket(socket.socket(),
                                             server_hostname="invalid") as s:
-                with self.assertRaisesRegex(
-                        ssl.CertificateError,
-                        "Hostname mismatch, certificate is not valid for 'invalid'."):
-                    s.connect((HOST, server.port))
+                if ssl.IS_WOLFSSL:
+                    with self.assertRaisesRegex(
+                           ssl.CertificateError,
+                            "peer subject name mismatch"):
+                        s.connect((HOST, server.port))
+                else:
+                    with self.assertRaisesRegex(
+                            ssl.CertificateError,
+                            "Hostname mismatch, certificate is not valid for 'invalid'."):
+                        s.connect((HOST, server.port))
 
         # missing server_hostname arg should cause an exception, too
         server = ThreadedEchoServer(context=server_context, chatty=True)
@@ -2964,7 +3152,9 @@
     def test_ecc_cert(self):
         client_context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
         client_context.load_verify_locations(SIGNING_CA)
-        client_context.set_ciphers('ECDHE:ECDSA:!NULL:!aRSA')
+        if not ssl.IS_WOLFSSL:
+            client_context.set_ciphers('ECDHE:ECDSA:!NULL:!aRSA')
+        
         hostname = SIGNED_CERTFILE_ECC_HOSTNAME
 
         server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
@@ -2989,13 +3179,19 @@
         #       algorithms.
         client_context.options |= ssl.OP_NO_TLSv1_3
         # only ECDSA certs
-        client_context.set_ciphers('ECDHE:ECDSA:!NULL:!aRSA')
+        if ssl.IS_WOLFSSL:
+            # wolfSSL doesn't support cipher rule
+            client_context.set_ciphers('ECDHE-ECDSA-AES256-GCM-SHA384')
+        else:
+            client_context.set_ciphers('ECDHE:ECDSA:!NULL:!aRSA')
         hostname = SIGNED_CERTFILE_ECC_HOSTNAME
-
+        
         server_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
         # load ECC and RSA key/cert pairs
         server_context.load_cert_chain(SIGNED_CERTFILE_ECC)
-        server_context.load_cert_chain(SIGNED_CERTFILE)
+        if not ssl.IS_WOLFSSL:
+            # wolfSSL handles one certificate
+            server_context.load_cert_chain(SIGNED_CERTFILE)
 
         # correct hostname should verify
         server = ThreadedEchoServer(context=server_context, chatty=True)
@@ -3116,21 +3312,38 @@
         with server, \
              client_context.wrap_socket(socket.socket(),
                                         server_hostname=hostname) as s:
-            # TLS 1.3 perform client cert exchange after handshake
-            s.connect((HOST, server.port))
-            try:
-                s.write(b'data')
-                s.read(4)
-            except ssl.SSLError as e:
-                if support.verbose:
-                    sys.stdout.write("\nSSLError is %r\n" % e)
-            except OSError as e:
-                if e.errno != errno.ECONNRESET:
-                    raise
-                if support.verbose:
-                    sys.stdout.write("\nsocket.error is %r\n" % e)
+            if ssl.IS_WOLFSSL:
+                # wolfSSL do_handshake performs client cert exchaange while doing handshaking
+                try:
+                    s.connect((HOST, server.port))
+                    s.write(b'data')
+                    s.read(4)
+                except ssl.SSLError as e:
+                    if support.verbose:
+                        sys.stdout.write("\nSSLError is %r\n" % e)
+                except OSError as e:
+                    if e.errno != errno.ECONNRESET:
+                        raise
+                    if support.verbose:
+                        sys.stdout.write("\nsocket.error is %r\n" % e)
+                else:
+                    self.fail("Use of invalid cert should have failed!")
             else:
-                self.fail("Use of invalid cert should have failed!")
+                # TLS 1.3 perform client cert exchange after handshake\
+                s.connect((HOST, server.port))
+                try:
+                    s.write(b'data')
+                    s.read(4)
+                except ssl.SSLError as e:
+                    if support.verbose:
+                        sys.stdout.write("\nSSLError is %r\n" % e)
+                except OSError as e:
+                    if e.errno != errno.ECONNRESET:
+                        raise
+                    if support.verbose:
+                        sys.stdout.write("\nsocket.error is %r\n" % e)
+                else:
+                    self.fail("Use of invalid cert should have failed!")
 
     def test_rude_shutdown(self):
         """A brutal shutdown of an SSL server should raise an OSError
@@ -3191,10 +3404,16 @@
                 except ssl.SSLError as e:
                     msg = 'unable to get local issuer certificate'
                     self.assertIsInstance(e, ssl.SSLCertVerificationError)
-                    self.assertEqual(e.verify_code, 20)
-                    self.assertEqual(e.verify_message, msg)
-                    self.assertIn(msg, repr(e))
-                    self.assertIn('certificate verify failed', repr(e))
+                    if ssl.IS_WOLFSSL:
+                        self.assertEqual(e.verify_code, 29)
+                        msg = 'unable to verify the first certificate'
+                        self.assertEqual(e.verify_message, msg)
+                        self.assertIn('ASN no signer error to confirm failure', repr(e))
+                    else:
+                        self.assertEqual(e.verify_code, 20)
+                        self.assertEqual(e.verify_message, msg)
+                        self.assertIn(msg, repr(e))
+                        self.assertIn('certificate verify failed', repr(e))
 
     @requires_tls_version('SSLv2')
     def test_protocol_sslv2(self):
@@ -3324,8 +3543,11 @@
             try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv2, False)
         if has_tls_version('SSLv3'):
             try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_SSLv3, False)
-        try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLS, False,
-                           client_options=ssl.OP_NO_TLSv1_2)
+        
+        if not ssl.IS_WOLFSSL:
+            # this expectes to work
+            try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLS, False,
+                               client_options=ssl.OP_NO_TLSv1_2)
 
         try_protocol_combo(ssl.PROTOCOL_TLS, ssl.PROTOCOL_TLSv1_2, 'TLSv1.2')
         try_protocol_combo(ssl.PROTOCOL_TLSv1_2, ssl.PROTOCOL_TLSv1, False)
@@ -3736,6 +3958,7 @@
                 sock.do_handshake()
             self.assertEqual(cm.exception.errno, errno.ENOTCONN)
 
+    @unittest.skipIf(ssl.IS_WOLFSSL, "wolfSSL doesn't support cipher rule.")
     def test_no_shared_ciphers(self):
         client_context, server_context, hostname = testing_context()
         # OpenSSL enables all TLS 1.3 ciphers, enforce TLS 1.2 for test
@@ -3838,7 +4061,10 @@
                                             server_hostname=hostname) as s:
                 with self.assertRaises(ssl.SSLError) as e:
                     s.connect((HOST, server.port))
-                self.assertIn("alert", str(e.exception))
+                if ssl.IS_WOLFSSL:
+                    self.assertIn("fatal error", str(e.exception))
+                else:
+                    self.assertIn("alert", str(e.exception))
 
     @requires_minimum_version
     @requires_tls_version('SSLv3')
@@ -3868,6 +4094,10 @@
         # automatically.
         if ssl.OPENSSL_VERSION_INFO < (1, 0, 0):
             context.set_ciphers("ECCdraft:ECDH")
+        if ssl.IS_WOLFSSL:
+            # Default first priority of cipher in the list of wolfSSL is 
+            # DHE-RSA-AES128-SHA
+            context.set_ciphers("ECDHE-RSA-AES128-SHA")
         with ThreadedEchoServer(context=context) as server:
             with context.wrap_socket(socket.socket()) as s:
                 s.connect((HOST, server.port))
@@ -3900,7 +4130,11 @@
                 # check if it is sane
                 self.assertIsNotNone(cb_data)
                 if s.version() == 'TLSv1.3':
-                    self.assertEqual(len(cb_data), 48)
+                    if ssl.IS_WOLFSSL:
+                        # wolfSSL returns 32 length because TLS_AES_128_GCM_SHA256 use
+                        self.assertEqual(len(cb_data), 32)
+                    else:
+                        self.assertEqual(len(cb_data), 48)
                 else:
                     self.assertEqual(len(cb_data), 12)  # True for TLSv1
 
@@ -3925,7 +4159,11 @@
                 self.assertNotEqual(cb_data, new_cb_data)
                 self.assertIsNotNone(cb_data)
                 if s.version() == 'TLSv1.3':
-                    self.assertEqual(len(cb_data), 48)
+                    if ssl.IS_WOLFSSL:
+                        # wolfSSL returns 32 length because TLS_AES_128_GCM_SHA256 use
+                        self.assertEqual(len(cb_data), 32)
+                    else:
+                        self.assertEqual(len(cb_data), 48)
                 else:
                     self.assertEqual(len(cb_data), 12)  # True for TLSv1
                 s.write(b"CB tls-unique\n")
@@ -3959,13 +4197,18 @@
         # test scenario needs TLS <= 1.2
         client_context.options |= ssl.OP_NO_TLSv1_3
         server_context.load_dh_params(DHFILE)
-        server_context.set_ciphers("kEDH")
+        if not ssl.IS_WOLFSSL:
+            # wolfSSL doesn't support cipher rules
+            server_context.set_ciphers("kEDH")
         server_context.options |= ssl.OP_NO_TLSv1_3
         stats = server_params_test(client_context, server_context,
                                    chatty=True, connectionchatty=True,
                                    sni_name=hostname)
         cipher = stats["cipher"][0]
-        parts = cipher.split("-")
+        if ssl.IS_WOLFSSL:
+            parts = cipher.split("_")
+        else:
+            parts = cipher.split("-")
         if "ADH" not in parts and "EDH" not in parts and "DHE" not in parts:
             self.fail("Non-DH cipher: " + cipher[0])
 
@@ -4166,7 +4409,10 @@
             stats = server_params_test(client_context, server_context,
                                        chatty=False,
                                        sni_name='supermessage')
-        self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')
+        if ssl.IS_WOLFSSL:
+            self.assertEqual(cm.exception.reason, 'fatal error')
+        else:
+            self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_ACCESS_DENIED')
 
     @needs_sni
     def test_sni_callback_raising(self):
@@ -4182,9 +4428,11 @@
                 stats = server_params_test(client_context, server_context,
                                            chatty=False,
                                            sni_name='supermessage')
-
-            self.assertEqual(cm.exception.reason,
-                             'SSLV3_ALERT_HANDSHAKE_FAILURE')
+            if ssl.IS_WOLFSSL:
+                self.assertEqual(cm.exception.reason, 'fatal error')
+            else:
+                self.assertEqual(cm.exception.reason,
+                                'SSLV3_ALERT_HANDSHAKE_FAILURE')
             self.assertEqual(catch.unraisable.exc_type, ZeroDivisionError)
 
     @needs_sni
@@ -4203,20 +4451,30 @@
                                            chatty=False,
                                            sni_name='supermessage')
 
-
-            self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_INTERNAL_ERROR')
+            if ssl.IS_WOLFSSL:
+                self.assertEqual(cm.exception.reason, 'fatal error')
+            else:
+                self.assertEqual(cm.exception.reason, 'TLSV1_ALERT_INTERNAL_ERROR')
             self.assertEqual(catch.unraisable.exc_type, TypeError)
 
     def test_shared_ciphers(self):
         client_context, server_context, hostname = testing_context()
-        client_context.set_ciphers("AES128:AES256")
-        server_context.set_ciphers("AES256")
+        if ssl.IS_WOLFSSL:
+            # wolfSSL doesn't support cipher rules.
+            client_context.set_ciphers("ECDHE-RSA-AES256-GCM-SHA384")
+            server_context.set_ciphers("ECDHE-ECDSA-AES256-GCM-SHA384")
+        else:
+            client_context.set_ciphers("AES128:AES256")
+            server_context.set_ciphers("AES256")
         expected_algs = [
             "AES256", "AES-256",
             # TLS 1.3 ciphers are always enabled
             "TLS_CHACHA20", "TLS_AES",
         ]
 
+        if ssl.IS_WOLFSSL:
+            expected_algs.append('AES_256')
+
         stats = server_params_test(client_context, server_context,
                                    sni_name=hostname)
         ciphers = stats['server_shared_ciphers'][0]
@@ -4267,20 +4525,26 @@
         self.assertTrue(session.id)
         self.assertGreater(session.time, 0)
         self.assertGreater(session.timeout, 0)
-        self.assertTrue(session.has_ticket)
+        if not ssl.IS_WOLFSSL:
+            #wolfSSL is not enabled session ticket as default
+            self.assertTrue(session.has_ticket)
         if ssl.OPENSSL_VERSION_INFO > (1, 0, 1):
             self.assertGreater(session.ticket_lifetime_hint, 0)
         self.assertFalse(stats['session_reused'])
         sess_stat = server_context.session_stats()
-        self.assertEqual(sess_stat['accept'], 1)
-        self.assertEqual(sess_stat['hits'], 0)
+        if not ssl.IS_WOLFSSL:
+            #skip sub-test for sess_accept and sess_hits because those API are STUB
+            self.assertEqual(sess_stat['accept'], 1)
+            self.assertEqual(sess_stat['hits'], 0)
 
         # reuse session
         stats = server_params_test(client_context, server_context,
                                    session=session, sni_name=hostname)
         sess_stat = server_context.session_stats()
-        self.assertEqual(sess_stat['accept'], 2)
-        self.assertEqual(sess_stat['hits'], 1)
+        if not ssl.IS_WOLFSSL:
+            #skip sub-test for sess_accept and sess_hits because those API are STUB
+            self.assertEqual(sess_stat['accept'], 2)
+            self.assertEqual(sess_stat['hits'], 1)
         self.assertTrue(stats['session_reused'])
         session2 = stats['session']
         self.assertEqual(session2.id, session.id)
@@ -4297,8 +4561,10 @@
         self.assertNotEqual(session3.id, session.id)
         self.assertNotEqual(session3, session)
         sess_stat = server_context.session_stats()
-        self.assertEqual(sess_stat['accept'], 3)
-        self.assertEqual(sess_stat['hits'], 1)
+        if not ssl.IS_WOLFSSL:
+            #skip sub-test for sess_accept and sess_hits because those API are STUB
+            self.assertEqual(sess_stat['accept'], 3)
+            self.assertEqual(sess_stat['hits'], 1)
 
         # reuse session again
         stats = server_params_test(client_context, server_context,
@@ -4310,8 +4576,10 @@
         self.assertGreaterEqual(session4.time, session.time)
         self.assertGreaterEqual(session4.timeout, session.timeout)
         sess_stat = server_context.session_stats()
-        self.assertEqual(sess_stat['accept'], 4)
-        self.assertEqual(sess_stat['hits'], 2)
+        if not ssl.IS_WOLFSSL:
+            #skip sub-test for sess_accept and sess_hits because those API are STUB
+            self.assertEqual(sess_stat['accept'], 4)
+            self.assertEqual(sess_stat['hits'], 2)
 
     def test_session_handling(self):
         client_context, server_context, hostname = testing_context()
@@ -4497,10 +4765,17 @@
             with client_context.wrap_socket(socket.socket(),
                                             server_hostname=hostname) as s:
                 s.connect((HOST, server.port))
-                with self.assertRaisesRegex(ssl.SSLError, 'not server'):
-                    s.verify_client_post_handshake()
-                s.write(b'PHA')
-                self.assertIn(b'extension not received', s.recv(1024))
+                # Error strings returned from wolfSSL are worded differently
+                if ssl.IS_WOLFSSL:
+                    with self.assertRaisesRegex(ssl.SSLError, 'wrong client/server type'):
+                        s.verify_client_post_handshake()
+                    s.write(b'PHA')
+                    self.assertIn(b'Client will not do post handshake authentication', s.recv(1024))
+                else:
+                    with self.assertRaisesRegex(ssl.SSLError, 'not server'):
+                        s.verify_client_post_handshake()
+                    s.write(b'PHA')
+                    self.assertIn(b'extension not received', s.recv(1024))
 
     def test_pha_no_pha_server(self):
         # server doesn't have PHA enabled, cert is requested in handshake
@@ -4616,7 +4891,11 @@
                                             server_hostname=hostname) as s:
                 s.connect((HOST, server.port))
         # header, 5 lines for TLS 1.3
-        self.assertEqual(self.keylog_lines(), 6)
+        if ssl.IS_WOLFSSL:
+            # Does not include EXPORTER
+            self.assertEqual(self.keylog_lines(), 5)
+        else:
+            self.assertEqual(self.keylog_lines(), 6)
 
         client_context.keylog_filename = None
         server_context.keylog_filename = support.TESTFN
@@ -4625,7 +4904,11 @@
             with client_context.wrap_socket(socket.socket(),
                                             server_hostname=hostname) as s:
                 s.connect((HOST, server.port))
-        self.assertGreaterEqual(self.keylog_lines(), 11)
+        if ssl.IS_WOLFSSL:
+            # Does not include EXPORTER
+            self.assertEqual(self.keylog_lines(), 9)
+        else:
+            self.assertGreaterEqual(self.keylog_lines(), 11)
 
         client_context.keylog_filename = support.TESTFN
         server_context.keylog_filename = support.TESTFN
@@ -4634,7 +4917,11 @@
             with client_context.wrap_socket(socket.socket(),
                                             server_hostname=hostname) as s:
                 s.connect((HOST, server.port))
-        self.assertGreaterEqual(self.keylog_lines(), 21)
+        if ssl.IS_WOLFSSL:
+            # Does not include EXPORTER
+            self.assertEqual(self.keylog_lines(), 17)
+        else:
+            self.assertGreaterEqual(self.keylog_lines(), 21)
 
         client_context.keylog_filename = None
         server_context.keylog_filename = None
diff -Naur a/Modules/_hashopenssl.c b/Modules/_hashopenssl.c
--- a/Modules/_hashopenssl.c	2021-09-16 08:35:22.346325831 -0700
+++ b/Modules/_hashopenssl.c	2021-09-10 14:24:36.252210948 -0700
@@ -18,6 +18,10 @@
 #include "hashlib.h"
 #include "pystrhex.h"
 
+#ifdef HAVE_WOLFSSL
+#include "wolfssl/options.h"
+#include "openssl/opensslconf.h"  /* for OPENSSL_THREADS define */
+#endif
 
 /* EVP is the preferred interface to hashing in OpenSSL */
 #include <openssl/evp.h>
@@ -30,7 +34,8 @@
 #  error "OPENSSL_THREADS is not defined, Python requires thread-safe OpenSSL"
 #endif
 
-#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)
+#if ((OPENSSL_VERSION_NUMBER < 0x10100000L) || defined(LIBRESSL_VERSION_NUMBER)) && \
+    !defined(HAVE_WOLFSSL)
 /* OpenSSL < 1.1.0 */
 #define EVP_MD_CTX_new EVP_MD_CTX_create
 #define EVP_MD_CTX_free EVP_MD_CTX_destroy
@@ -38,7 +43,8 @@
 
 #define MUNCH_SIZE INT_MAX
 
-#ifdef NID_sha3_224
+#if defined(NID_sha3_224) || \
+    (defined(HAVE_WOLFSSL) && defined(WOLFSSL_SHA3))
 #define PY_OPENSSL_HAS_SHA3 1
 #endif
 
@@ -126,7 +132,8 @@
     case NID_sha512:
         name ="sha512";
         break;
-#ifdef NID_sha512_224
+#if defined(NID_sha512_224) || (defined(HAVE_WOLFSSL) && \
+    defined(WOLFSSL_SHA512) && !defined(WOLFSSL_NOSHA512_224))
     case NID_sha512_224:
         name ="sha512_224";
         break;
diff -Naur a/Modules/_ssl.c b/Modules/_ssl.c
--- a/Modules/_ssl.c	2021-09-16 08:35:22.342325987 -0700
+++ b/Modules/_ssl.c	2021-09-16 08:32:37.520740247 -0700
@@ -54,6 +54,10 @@
 #endif
 
 /* Include OpenSSL header files */
+#ifdef HAVE_WOLFSSL
+#include "wolfssl/options.h"
+#include "openssl/opensslconf.h"  /* for OPENSSL_THREADS define */
+#endif
 #include "openssl/rsa.h"
 #include "openssl/crypto.h"
 #include "openssl/x509.h"
@@ -170,17 +174,42 @@
 /* SNI support (client- and server-side) appeared in OpenSSL 1.0.0 and 0.9.8f
  * This includes the SSL_set_SSL_CTX() function.
  */
-#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME
+#if defined(SSL_CTRL_SET_TLSEXT_HOSTNAME) || \
+    (defined(HAVE_WOLFSSL) && defined(HAVE_SNI))
+#undef HAVE_SNI
 # define HAVE_SNI 1
 #else
 # define HAVE_SNI 0
 #endif
 
-#ifdef TLSEXT_TYPE_application_layer_protocol_negotiation
+#if !defined(HAVE_ALPN) || defined(HAVE_WOLFSSL)
+#if defined(TLSEXT_TYPE_application_layer_protocol_negotiation) || \
+    defined(HAVE_WOLFSSL)
+#ifdef HAVE_WOLFSSL
+/* wolfSSL defines HAVE_ALPN, but without a value. Undef and redefine here */
+#undef HAVE_ALPN
+#endif
 # define HAVE_ALPN 1
 #else
 # define HAVE_ALPN 0
 #endif
+#endif
+
+#ifdef HAVE_WOLFSSL
+    #define OPENSSL_NO_SSL2
+    #if defined(NO_OLD_TLS) || !defined(WOLFSSL_ALLOW_SSLV3)
+        #define OPENSSL_NO_SSL3
+    #endif
+    #if defined(NO_OLD_TLS) || !defined(WOLFSSL_ALLOW_TLSV10)
+        #define OPENSSL_NO_TLS1
+    #endif
+    #if defined(NO_OLD_TLS)
+        #define OPENSSL_NO_TLS1_1
+    #endif
+    #ifdef WOLFSSL_NO_TLS12
+        #define OPENSSL_NO_TLS1_2
+    #endif
+#endif
 
 /* We cannot rely on OPENSSL_NO_NEXTPROTONEG because LibreSSL 2.6.1 dropped
  * NPN support but did not set OPENSSL_NO_NEXTPROTONEG for compatibility
@@ -215,9 +244,10 @@
 #define OPENSSL_NO_SSL2
 #endif
 
-#ifndef PY_OPENSSL_1_1_API
+#if !defined(PY_OPENSSL_1_1_API) || defined(HAVE_WOLFSSL)
 /* OpenSSL 1.1 API shims for OpenSSL < 1.1.0 and LibreSSL < 2.7.0 */
 
+#ifndef HAVE_WOLFSSL
 #define TLS_method SSLv23_method
 #define TLS_client_method SSLv23_client_method
 #define TLS_server_method SSLv23_server_method
@@ -227,6 +257,7 @@
 #define OpenSSL_version_num SSLeay
 #define OpenSSL_version SSLeay_version
 #define OPENSSL_VERSION SSLEAY_VERSION
+#endif
 
 static int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne)
 {
@@ -242,6 +273,7 @@
 /* LCOV_EXCL_STOP */
 #endif
 
+#ifndef HAVE_WOLFSSL
 static pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx)
 {
     return ctx->default_passwd_callback;
@@ -283,6 +315,7 @@
 {
     return s->tlsext_tick_lifetime_hint;
 }
+#endif
 
 #endif /* OpenSSL < 1.1.0 or LibreSSL < 2.7.0 */
 
@@ -503,7 +536,11 @@
         _PySSL_FIX_ERRNO;
 #endif
         err.c = errno;
+#ifdef HAVE_WOLFSSL
+        err.ssl = SSL_get_error((SSL*)ssl, retcode);
+#else
         err.ssl = SSL_get_error(ssl, retcode);
+#endif
     }
     return err;
 }
@@ -636,8 +673,10 @@
         if (lib_obj == NULL && PyErr_Occurred()) {
             goto fail;
         }
-        if (errstr == NULL)
+        if (errstr == NULL) {
             errstr = ERR_reason_error_string(errcode);
+
+        }
     }
     if (errstr == NULL)
         errstr = "unknown error";
@@ -671,6 +710,13 @@
             );
             break;
 #endif
+#ifdef HAVE_WOLFSSL
+        case X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE:
+            verify_obj = PyUnicode_FromFormat(
+                "unable to verify the first certificate"
+            );
+            break;
+#endif
         default:
             verify_str = X509_verify_cert_error_string(verify_code);
             if (verify_str != NULL) {
@@ -762,7 +808,7 @@
 
     if (sslsock->ssl != NULL) {
         err = sslsock->err;
-
+        
         switch (err.ssl) {
         case SSL_ERROR_ZERO_RETURN:
             errstr = "TLS/SSL connection has been closed (EOF)";
@@ -788,8 +834,16 @@
             errstr = "The operation did not complete (connect)";
             break;
         case SSL_ERROR_SYSCALL:
+#ifdef  HAVE_WOLFSSL
+        case SOCKET_PEER_CLOSED_E:
+        case NO_PEER_CERT:
+#endif
         {
+#ifdef HAVE_WOLFSSL
+            if (e == -1*SOCKET_PEER_CLOSED_E || e == 0) {
+#else
             if (e == 0) {
+#endif
                 PySocketSockObject *s = GET_SOCKET(sslsock);
                 if (ret == 0 || (((PyObject *)s) == Py_None)) {
                     p = PY_SSL_ERROR_EOF;
@@ -834,6 +888,67 @@
             }
             break;
         }
+#ifdef HAVE_WOLFSSL
+        case ASN_NO_SIGNER_E:
+        {
+            p = PY_SSL_ERROR_SSL;
+            type = PySSLCertVerificationErrorObject;
+            break;
+        }
+        case VERSION_ERROR:
+        {
+            p = PY_SSL_ERROR_SSL;
+            errstr = "record layer version error";
+            break;
+        }
+        case NO_PRIVATE_KEY:
+        {
+            p = PY_SSL_ERROR_SSL;
+            errstr = "need the private key";
+            break;
+        }
+        case SOCKET_ERROR_E:
+        {
+            p = PY_SSL_ERROR_SSL;
+            errstr = "error state on socket";
+            break;
+        }
+        case DOMAIN_NAME_MISMATCH:
+        {
+            p = PY_SSL_ERROR_SSL;
+            type = PySSLCertVerificationErrorObject;
+            errstr = "peer subject name mismatch";
+            break;
+        }
+        case MATCH_SUITE_ERROR:
+        {
+            p = PY_SSL_ERROR_SSL;
+            errstr = "can't match cipher suite";
+            break;
+        }
+        case FATAL_ERROR:
+        {
+            WOLFSSL_ALERT_HISTORY h;
+
+            p = PY_SSL_ERROR_SSL;
+            if (ERR_GET_LIB(e) == ERR_LIB_SSL &&
+                    ERR_GET_REASON(e) == SSL_R_CERTIFICATE_VERIFY_FAILED) {
+                type = PySSLCertVerificationErrorObject;
+            }
+
+            wolfSSL_get_alert_history(sslsock->ssl, &h);
+            if (h.last_rx.code == certificate_required) {
+                errstr = "tlsv13 alert certificate required";
+            }
+            break;
+        }
+        case POST_HAND_AUTH_ERROR:
+        {
+            p = PY_SSL_ERROR_SSL;
+            errstr = "extension not received";
+            break;
+        }
+#endif
         default:
             p = PY_SSL_ERROR_INVALID_ERROR_CODE;
             errstr = "Invalid error code";
@@ -1116,8 +1231,8 @@
         } else if (sockstate == SOCKET_IS_NONBLOCKING) {
             break;
         }
-    } while (err.ssl == SSL_ERROR_WANT_READ ||
-             err.ssl == SSL_ERROR_WANT_WRITE);
+    } while (ret >= 0 && (err.ssl == SSL_ERROR_WANT_READ ||
+             err.ssl == SSL_ERROR_WANT_WRITE));
     Py_XDECREF(sock);
     if (ret < 1)
         return PySSL_SetError(self, ret, __FILE__, __LINE__);
@@ -1159,6 +1274,7 @@
             goto done;
         }
     }
+
     if (!buflen && no_name) {
         Py_INCREF(Py_None);
         name_obj = Py_None;
@@ -1222,7 +1338,9 @@
 
         /* check to see if we've gotten to a new RDN */
         if (rdn_level >= 0) {
+            #ifndef HAVE_WOLFSSL
             if (rdn_level != X509_NAME_ENTRY_set(entry)) {
+            #endif
                 /* yes, new RDN */
                 /* add old RDN to DN */
                 rdnt = PyList_AsTuple(rdn);
@@ -1237,7 +1355,9 @@
                 rdn = PyList_New(0);
                 if (rdn == NULL)
                     goto fail0;
+            #ifndef HAVE_WOLFSSL
             }
+            #endif
         }
         rdn_level = X509_NAME_ENTRY_set(entry);
 
@@ -1309,8 +1429,9 @@
     char *vptr;
     int len;
 
-    if (certificate == NULL)
+    if (certificate == NULL) {
         return peer_alt_names;
+    }
 
     /* get a memory buffer */
     biobuf = BIO_new(BIO_s_mem());
@@ -1441,14 +1562,14 @@
                 PyTuple_SET_ITEM(t, 0, v);
 
                 if (name->d.ip->length == 4) {
-                    unsigned char *p = name->d.ip->data;
+                    unsigned char *p = (unsigned char*)name->d.ip->data;
                     v = PyUnicode_FromFormat(
                         "%d.%d.%d.%d",
                         p[0], p[1], p[2], p[3]
                     );
                 } else if (name->d.ip->length == 16) {
                     /* PyUnicode_FromFormat() does not support %X */
-                    unsigned char *p = name->d.ip->data;
+                    unsigned char *p = (unsigned char*)name->d.ip->data;
                     len = sprintf(
                         buf,
                         "%X:%X:%X:%X:%X:%X:%X:%X",
@@ -1559,8 +1680,21 @@
     PyObject *lst = NULL, *ostr = NULL;
     int i, result;
     AUTHORITY_INFO_ACCESS *info;
-
+    #ifdef HAVE_WOLFSSL
+    X509_EXTENSION* ext;
+    int loc = 0;
+    #endif
+    
+    #ifdef HAVE_WOLFSSL
+    loc = X509_get_ext_by_NID(certificate, NID_info_access, -1);
+    if (loc < 0)
+        return Py_None;
+    if((ext = X509_get_ext(certificate, loc)) == NULL)
+        return Py_None;
+    info = X509V3_EXT_d2i(ext);
+    #else
     info = X509_get_ext_d2i(certificate, NID_info_access, NULL, NULL);
+    #endif
     if (info == NULL)
         return Py_None;
     if (sk_ACCESS_DESCRIPTION_num(info) == 0) {
@@ -1792,6 +1926,7 @@
         Py_DECREF(peer_alt_names);
     }
 
+
     /* Authority Information Access: OCSP URIs */
     obj = _get_aia_uri(certificate, NID_ad_OCSP);
     if (obj == NULL) {
@@ -1931,8 +2066,9 @@
         return NULL;
     }
     peer_cert = SSL_get_peer_certificate(self->ssl);
-    if (peer_cert == NULL)
+    if (peer_cert == NULL) {
         Py_RETURN_NONE;
+    }
 
     if (binary_mode) {
         /* return cert in DER-encoded format */
@@ -2154,7 +2290,11 @@
 
     SSL_get0_alpn_selected(self->ssl, &out, &outlen);
 
+#ifdef HAVE_WOLFSSL
+    if (out == NULL || outlen == 0)
+#else
     if (out == NULL)
+#endif
         Py_RETURN_NONE;
     return PyUnicode_FromStringAndSize((char *)out, outlen);
 }
@@ -2589,12 +2729,12 @@
         PySSL_END_ALLOW_THREADS
         self->err = err;
 
-        if (PyErr_CheckSignals())
+        if (PyErr_CheckSignals()) {
             goto error;
+        }
 
         if (has_timeout)
             timeout = deadline - _PyTime_GetMonotonicClock();
-
         if (err.ssl == SSL_ERROR_WANT_READ) {
             sockstate = PySSL_select(sock, 0, timeout);
         } else if (err.ssl == SSL_ERROR_WANT_WRITE) {
@@ -2659,7 +2799,6 @@
     PySocketSockObject *sock = GET_SOCKET(self);
     _PyTime_t timeout, deadline = 0;
     int has_timeout;
-
     if (sock != NULL) {
         /* Guard against closed socket */
         if ((((PyObject*)sock) == Py_None) || (sock->sock_fd == INVALID_SOCKET)) {
@@ -3100,11 +3239,13 @@
 
     PySSL_BEGIN_ALLOW_THREADS
     switch(proto_version) {
-#if defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3)
+#if (defined(SSL3_VERSION) && !defined(OPENSSL_NO_SSL3))
+#if !defined(HAVE_WOLFSSL) || (defined(HAVE_WOLFSSL) && defined(WOLFSSL_ALLOW_SSLV3))
     case PY_SSL_VERSION_SSL3:
         ctx = SSL_CTX_new(SSLv3_method());
         break;
 #endif
+#endif
 #if (defined(TLS1_VERSION) && \
         !defined(OPENSSL_NO_TLS1) && \
         !defined(OPENSSL_NO_TLS1_METHOD))
@@ -3205,7 +3346,7 @@
 #ifdef SSL_OP_SINGLE_DH_USE
     options |= SSL_OP_SINGLE_DH_USE;
 #endif
-#ifdef SSL_OP_SINGLE_ECDH_USE
+#if defined(SSL_OP_SINGLE_ECDH_USE) || defined(HAVE_WOLFSSL)
     options |= SSL_OP_SINGLE_ECDH_USE;
 #endif
     SSL_CTX_set_options(self->ctx, options);
@@ -5322,9 +5463,11 @@
     if (bytes == NULL)
         return NULL;
     if (pseudo) {
-#ifdef PY_OPENSSL_1_1_API
+#if defined(PY_OPENSSL_1_1_API) && !defined(HAVE_WOLFSSL)
         ok = RAND_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);
 #else
+        /* wolfSSL using RAND_pseudo_bytes for fork test where bytes input is
+         * used as seed in addition to secret data created for result */
         ok = RAND_pseudo_bytes((unsigned char*)PyBytes_AS_STRING(bytes), len);
 #endif
         if (ok == 0 || ok == 1)
@@ -6046,7 +6189,7 @@
     if (!_setup_ssl_threads()) {
         return NULL;
     }
-#elif OPENSSL_VERSION_1_1
+#elif OPENSSL_VERSION_1_1 || defined(HAVE_WOLFSSL)
     /* OpenSSL 1.1.0 builtin thread support is enabled */
     _ssl_locks_count++;
 #endif
@@ -6145,8 +6288,10 @@
                             X509_V_FLAG_CRL_CHECK);
     PyModule_AddIntConstant(m, "VERIFY_CRL_CHECK_CHAIN",
                             X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL);
+#ifndef HAVE_WOLFSSL
     PyModule_AddIntConstant(m, "VERIFY_X509_STRICT",
                             X509_V_FLAG_X509_STRICT);
+#endif
 #ifdef X509_V_FLAG_TRUSTED_FIRST
     PyModule_AddIntConstant(m, "VERIFY_X509_TRUSTED_FIRST",
                             X509_V_FLAG_TRUSTED_FIRST);
@@ -6433,5 +6578,11 @@
     if (r == NULL || PyModule_AddObject(m, "_OPENSSL_API_VERSION", r))
         return NULL;
 
+#ifdef HAVE_WOLFSSL
+    addbool(m, "IS_WOLFSSL", 1);
+#else
+    addbool(m, "IS_WOLFSSL", 0);
+#endif
+
     return m;
 }
diff -Naur a/Modules/_ssl_data.h b/Modules/_ssl_data.h
--- a/Modules/_ssl_data.h	2021-09-16 08:35:22.350325675 -0700
+++ b/Modules/_ssl_data.h	2021-09-13 09:06:02.648155994 -0700
@@ -80,6 +80,9 @@
 #ifdef ERR_LIB_X509V3
     {"X509V3", ERR_LIB_X509V3},
 #endif
+#ifdef HAVE_WOLFSSL
+    {"wolfSSL", 0},
+#endif
     { NULL }
 };
 
@@ -6319,5 +6322,10 @@
   #else
     {"WRONG_TYPE", 11, 122},
   #endif
+  #ifdef HAVE_WOLFSSL
+  #define WOLFSSL_ERRORCODE(x)  x<0?(-1*x):x
+    {"error state on socket", 0, WOLFSSL_ERRORCODE(SOCKET_ERROR_E)},
+    {"fatal error", 0, WOLFSSL_ERRORCODE(FATAL_ERROR)},
+  #endif
     { NULL }
 };
diff -Naur a/pyconfig.h.in b/pyconfig.h.in
--- a/pyconfig.h.in	2021-09-16 08:35:22.270328788 -0700
+++ b/pyconfig.h.in	2021-08-26 15:42:06.560328000 -0700
@@ -1325,6 +1325,9 @@
 /* Define to 1 if you have the `wmemcmp' function. */
 #undef HAVE_WMEMCMP
 
+/* define if you are using wolfSSL */
+#undef HAVE_WOLFSSL
+
 /* Define if tzset() actually switches the local timezone in a meaningful way.
    */
 #undef HAVE_WORKING_TZSET
@@ -1352,6 +1355,12 @@
 /* Define if mvwdelch in curses.h is an expression. */
 #undef MVWDELCH_IS_EXPRESSION
 
+/* define to disable compression */
+#undef OPENSSL_NO_COMP
+
+/* define to disable scrypt */
+#undef OPENSSL_NO_SCRYPT
+
 /* Define to the address where bug reports for this package should be sent. */
 #undef PACKAGE_BUGREPORT
 
