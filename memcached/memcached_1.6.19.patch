commit 1e996cea808c443af0703f2b2ddc09a3a6750652
Author: Kareem <kareem@wolfssl.com>
Date:   Wed Apr 12 10:40:59 2023 -0700

    Add wolfSSL support to memcached.
    
    To use, build wolfSSL with:
    ./configure --enable-memcached
    make
    sudo make install
    
    Then build and test memcached with:
    ./configure --enable-wolfssl
    make
    make test
    
    All memcached tests are expected to pass.

diff --git a/Makefile.am b/Makefile.am
index 43315cf..e71f9a8 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -77,6 +77,10 @@ if ENABLE_TLS
 memcached_SOURCES += tls.c tls.h
 endif
 
+if ENABLE_WOLFSSL
+memcached_SOURCES += wolfssl.c wolfssl.h
+endif
+
 memcached_debug_SOURCES = $(memcached_SOURCES)
 memcached_CPPFLAGS = -DNDEBUG
 memcached_debug_LDADD = @PROFILER_LDFLAGS@
@@ -162,6 +166,21 @@ test_basic_tls:
 	fi
 endif
 
+if ENABLE_WOLFSSL
+test_tls:
+	$(MAKE) SSL_TEST=1 test
+
+test_basic_tls:
+	@if test $(SSL_TEST)1 != 1; then \
+	  echo "Running basic tests with TLS"; \
+	  $(builddir)/testapp && \
+	  prove $(srcdir)/t/binary.t $(srcdir)/t/getset.t $(srcdir)/t/ssl* && \
+	  echo "Finished running basic TLS tests"; \
+	else \
+	  echo "Set SSL_TEST=1 to enable TLS tests"; \
+	fi
+endif
+
 test:	memcached-debug sizes testapp
 	$(builddir)/sizes
 	$(builddir)/testapp
@@ -169,6 +188,11 @@ if ENABLE_TLS
 	@if test $(SSL_TEST)1 = 1; then \
           $(MAKE) SSL_TEST=1  test_basic_tls; \
 	fi
+endif
+if ENABLE_WOLFSSL
+	@if test $(SSL_TEST)1 = 1; then \
+          $(MAKE) SSL_TEST=1  test_basic_tls; \
+	fi
 endif
 	@if test -n "${PARALLEL}"; then \
 	  prove $(srcdir)/t -j ${PARALLEL}; \
diff --git a/README.md b/README.md
index 8fe067b..d312491 100644
--- a/README.md
+++ b/README.md
@@ -22,6 +22,8 @@ list to ask questions, github issues aren't seen by everyone!
   better security. Tested only on x86-64 architectures.
 * openssl (optional) - enables TLS support. need relatively up to date
   version. pkg-config is needed to find openssl dependencies (such as -lz).
+* wolfssl (optional) - enables TLS support, as an alternate to openssl.
+  need 5.6.1 or higher.
 
 ## Environment
 
diff --git a/configure.ac b/configure.ac
index e6bc4ba..9a44e56 100644
--- a/configure.ac
+++ b/configure.ac
@@ -114,6 +114,9 @@ AS_IF([test "x$enable_sasl_pwdb" = "xyes"],
 AC_ARG_ENABLE(tls,
   [AS_HELP_STRING([--enable-tls], [Enable Transport Layer Security EXPERIMENTAL ])])
 
+AC_ARG_ENABLE(wolfssl,
+  [AS_HELP_STRING([--enable-wolfssl], [Enable Transport Layer Security using wolfSSL ])])
+
 
 AC_ARG_ENABLE(asan,
   [AS_HELP_STRING([--enable-asan], [Compile with ASAN EXPERIMENTAL ])])
@@ -228,6 +231,10 @@ if test "x$enable_tls" = "xyes"; then
     AC_DEFINE([TLS],1,[Set to nonzero if you want to enable TLS])
 fi
 
+if test "x$enable_wolfssl" = "xyes"; then
+    AC_DEFINE([WOLFSSL_MEMCACHED],1,[Set to nonzero if using wolfSSL])
+fi
+
 if test "x$enable_asan" = "xyes"; then
     AC_DEFINE([ASAN],1,[Set to nonzero if you want to compile using ASAN])
 fi
@@ -258,6 +265,7 @@ AM_CONDITIONAL([ENABLE_SASL],[test "$enable_sasl" = "yes"])
 AM_CONDITIONAL([ENABLE_EXTSTORE],[test "$enable_extstore" != "no"])
 AM_CONDITIONAL([ENABLE_ARM_CRC32],[test "$enable_arm_crc32" = "yes"])
 AM_CONDITIONAL([ENABLE_TLS],[test "$enable_tls" = "yes"])
+AM_CONDITIONAL([ENABLE_WOLFSSL],[test "$enable_wolfssl" = "yes"])
 AM_CONDITIONAL([ENABLE_ASAN],[test "$enable_asan" = "yes"])
 AM_CONDITIONAL([ENABLE_STATIC],[test "$enable_static" = "yes"])
 AM_CONDITIONAL([DISABLE_UNIX_SOCKET],[test "$enable_unix_socket" = "no"])
@@ -533,6 +541,104 @@ if test "x$enable_tls" = "xyes"; then
   ])
 fi
 
+trywolfssldir=""
+AC_ARG_WITH(wolfssl,
+       [  --with-wolfssl=PATH     Specify path to wolfssl installation ],
+       [
+                if test "x$withval" != "xno" ; then
+                        trywolfssldir=$withval
+                fi
+       ]
+)
+
+dnl ----------------------------------------------------------------------------
+dnl wolfssl detection.  swiped from libevent.  modified for wolfssl detection.
+
+WOLFSSL_URL=https://www.wolfssl.com/
+if test "x$enable_wolfssl" = "xyes"; then
+  PKG_CHECK_MODULES(WOLFSSL, wolfssl, [
+    PKG_CHECK_VAR([WOLFSSL_INCLUDEDIR], [wolfssl], [includedir],
+      [CFLAGS="$CFLAGS -I$WOLFSSL_INCLUDEDIR -I$WOLFSSL_INCLUDEDIR/wolfssl"])
+    LIBS="$LIBS $WOLFSSL_LIBS" CFLAGS="$CFLAGS $WOLFSSL_CFLAGS"], [
+    AC_CACHE_CHECK([for wolfssl directory], ac_cv_wolfssl_dir, [
+      saved_LIBS="$LIBS"
+      saved_LDFLAGS="$LDFLAGS"
+      saved_CPPFLAGS="$CPPFLAGS"
+      le_found=no
+      for ledir in $trywolfssldir "" $prefix /usr/local ; do
+        LDFLAGS="$saved_LDFLAGS"
+        LIBS="-lwolfssl $saved_LIBS"
+
+        # Skip the directory if it isn't there.
+        if test ! -z "$ledir" -a ! -d "$ledir" ; then
+          continue;
+        fi
+        if test ! -z "$ledir" ; then
+          if test -d "$ledir/lib" ; then
+            LDFLAGS="-L$ledir/lib $LDFLAGS"
+          else
+            LDFLAGS="-L$ledir $LDFLAGS"
+          fi
+          if test -d "$ledir/include" ; then
+            CPPFLAGS="-I$ledir/include/wolfssl -I$ledir/include $CPPFLAGS"
+          else
+            CPPFLAGS="-I$ledir/wolfssl -I$ledir $CPPFLAGS"
+          fi
+        fi
+        # Can I compile and link it?
+        AC_TRY_LINK([#include <sys/time.h>
+    #include <sys/types.h>
+    #include <assert.h>
+    #ifndef WOLFSSL_USER_SETTINGS
+      #include <wolfssl/options.h>
+    #endif
+    #include <wolfssl/wolfcrypt/settings.h>
+    #include <wolfssl/ssl.h>], [ WOLFSSL_CTX* ssl_ctx = WOLFSSL_CTX_new(wolfTLS_server_method());
+                                assert(LIBWOLFSSL_VERSION_HEX >= 0x05006000L);],
+           [ wolfssl_linked=yes ], [ wolfssl_linked=no ])
+        if test $wolfssl_linked = yes; then
+          if test ! -z "$ledir" ; then
+            ac_cv_wolfssl_dir=$ledir
+            _myos=`echo $target_os | cut -f 1 -d .`
+            AS_IF(test "$SUNCC" = "yes" -o "x$_myos" = "xsolaris2",
+                  [saved_LDFLAGS="$saved_LDFLAGS -Wl,-R$ledir/lib"],
+                  [AS_IF(test "$GCC" = "yes",
+                        [saved_LDFLAGS="$saved_LDFLAGS -Wl,-rpath,$ledir/lib"])])
+           else
+             ac_cv_libssl_dir="(system)"
+           fi
+           le_found=yes
+           break
+        fi
+      done
+      LIBS="$saved_LIBS"
+      LDFLAGS="$saved_LDFLAGS"
+      CPPFLAGS="$saved_CPPFLAGS"
+      if test $le_found = no ; then
+        AC_MSG_ERROR([wolfssl (at least version 5.6.1) is required.  You can get it from $WOLFSSL_URL
+
+          If it's already installed, specify its path using --with-wolfssl=/dir/
+    ])
+      fi
+    ])
+    LIBS="-lwolfssl $LIBS"
+    if test $ac_cv_wolfssl_dir != "(system)"; then
+      if test -d "$ac_cv_wolfssl_dir/lib" ; then
+        LDFLAGS="-L$ac_cv_wolfssl_dir/lib $LDFLAGS"
+        le_libdir="$ac_cv_wolfssl_dir/lib"
+      else
+        LDFLAGS="-L$ac_cv_wolfssl_dir $LDFLAGS"
+        le_libdir="$ac_cv_wolfssl_dir"
+      fi
+      if test -d "$ac_cv_wolfssl_dir/include" ; then
+        CPPFLAGS="-I$ac_cv_wolfssl_dir/include/wolfssl -I$ac_cv_wolfssl_dir/include $CPPFLAGS"
+      else
+        CPPFLAGS="-I$ac_cv_wolfssl_dir/wolfssl -I$ac_cv_wolfssl_dir $CPPFLAGS"
+      fi
+    fi
+  ])
+fi
+
 if test "x$enable_static" = "xyes"; then
   LIBS="$LIBS -ldl"
   LDFLAGS="-static $LDFLAGS"
diff --git a/memcached.c b/memcached.c
index 15bbf36..f57c6dd 100644
--- a/memcached.c
+++ b/memcached.c
@@ -54,6 +54,11 @@
 #include "tls.h"
 #endif
 
+#ifdef WOLFSSL_MEMCACHED
+#include "wolfssl.h"
+#include <poll.h>
+#endif
+
 #include "proto_text.h"
 #include "proto_bin.h"
 #include "proto_proxy.h"
@@ -221,7 +226,7 @@ static void settings_init(void) {
     settings.access = 0700;
     settings.port = 11211;
     settings.udpport = 0;
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     settings.ssl_enabled = false;
     settings.ssl_ctx = NULL;
     settings.ssl_chain_cert = NULL;
@@ -234,7 +239,11 @@ static void settings_init(void) {
     settings.ssl_wbuf_size = 16 * 1024; // default is 16KB (SSL max frame size is 17KB)
     settings.ssl_session_cache = false;
     settings.ssl_kernel_tls = false;
+#ifdef TLS
     settings.ssl_min_version = TLS1_2_VERSION;
+#elif WOLFSSL_MEMCACHED
+    settings.ssl_min_version = WOLFSSL_TLSV1_2;
+#endif
 #endif
     /* By default this string should be NULL for getaddrinfo() */
     settings.inter = NULL;
@@ -727,7 +736,7 @@ conn *conn_new(const int sfd, enum conn_states init_state,
         }
     }
 
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     c->ssl = NULL;
     c->ssl_wbuf = NULL;
     c->ssl_enabled = false;
@@ -762,6 +771,14 @@ conn *conn_new(const int sfd, enum conn_states init_state,
         c->ssl_enabled = true;
         SSL_set_info_callback(c->ssl, ssl_callback);
     } else
+#elif defined(WOLFSSL_MEMCACHED)
+    if (ssl) {
+        c->ssl = (WOLFSSL*)ssl;
+        c->read = ssl_read;
+        c->sendmsg = ssl_sendmsg;
+        c->write = ssl_write;
+        c->ssl_enabled = true;
+    } else
 #else
     // This must be NULL if TLS is not enabled.
     assert(ssl == NULL);
@@ -888,7 +905,7 @@ void conn_free(conn *c) {
         conns[c->sfd] = NULL;
         if (c->rbuf)
             free(c->rbuf);
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
         if (c->ssl_wbuf)
             c->ssl_wbuf = NULL;
 #endif
@@ -927,6 +944,12 @@ static void conn_close(conn *c) {
         SSL_shutdown(c->ssl);
         SSL_free(c->ssl);
     }
+#endif
+#ifdef WOLFSSL_MEMCACHED
+    if (c->ssl) {
+        wolfSSL_shutdown(c->ssl);
+        wolfSSL_free(c->ssl);
+    }
 #endif
     close(c->sfd);
     c->close_reason = 0;
@@ -1889,7 +1912,7 @@ void server_stats(ADD_STAT add_stats, conn *c) {
 #ifdef PROXY
     proxy_stats(settings.proxy_ctx, add_stats, c);
 #endif
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     if (settings.ssl_enabled) {
         if (settings.ssl_session_cache) {
             APPEND_STAT("ssl_new_sessions", "%llu", (unsigned long long)stats.ssl_new_sessions);
@@ -1976,7 +1999,7 @@ void process_stat_settings(ADD_STAT add_stats, void *c) {
     APPEND_STAT("slab_automove_freeratio", "%.3f", settings.slab_automove_freeratio);
     APPEND_STAT("ext_drop_unread", "%s", settings.ext_drop_unread ? "yes" : "no");
 #endif
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     APPEND_STAT("ssl_enabled", "%s", settings.ssl_enabled ? "yes" : "no");
     APPEND_STAT("ssl_chain_cert", "%s", settings.ssl_chain_cert);
     APPEND_STAT("ssl_key", "%s", settings.ssl_key);
@@ -3038,8 +3061,12 @@ static void drive_machine(conn *c) {
                 close(sfd);
             } else {
                 void *ssl_v = NULL;
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
 #ifdef TLS
                 SSL *ssl = NULL;
+#elif WOLFSSL_MEMCACHED
+                WOLFSSL *ssl = NULL;
+#endif
                 if (c->ssl_enabled) {
                     assert(IS_TCP(c->transport) && settings.ssl_enabled);
 
@@ -3051,7 +3078,11 @@ static void drive_machine(conn *c) {
                         break;
                     }
                     SSL_LOCK();
+#ifdef TLS
                     ssl = SSL_new(settings.ssl_ctx);
+#elif WOLFSSL_MEMCACHED
+                    ssl = wolfSSL_new(settings.ssl_ctx);
+#endif
                     SSL_UNLOCK();
                     if (ssl == NULL) {
                         if (settings.verbose) {
@@ -3060,6 +3091,7 @@ static void drive_machine(conn *c) {
                         close(sfd);
                         break;
                     }
+#ifdef TLS
                     SSL_set_fd(ssl, sfd);
                     int ret = SSL_accept(ssl);
                     if (ret <= 0) {
@@ -3076,6 +3108,45 @@ static void drive_machine(conn *c) {
                             break;
                         }
                     }
+#elif WOLFSSL_MEMCACHED
+                    wolfSSL_set_fd(ssl, sfd);
+                    int ret = wolfSSL_accept(ssl);
+                    if (ret != WOLFSSL_SUCCESS) {
+                        int err = wolfSSL_get_error(ssl, ret);
+                        if (err != WOLFSSL_ERROR_WANT_READ && err != WOLFSSL_ERROR_WANT_WRITE) {
+                            if (settings.verbose) {
+                                fprintf(stderr, "SSL connection failed with error code : %d : %s\n",
+                                        err, wolfSSL_ERR_reason_error_string(err));
+                            }
+                            wolfSSL_free(ssl);
+                            close(sfd);
+                            STATS_LOCK();
+                            stats.ssl_handshake_errors++;
+                            STATS_UNLOCK();
+                            break;
+                        }
+                        else {
+                            /* Unlike OpenSSL, wolfSSL does not automatically retry
+                               on non-blocking connections, the application must
+                               repeat the call until it succeeds when WANT_READ/WANT_WRITE
+                               is returned. */
+                            int maxRetries = 10;
+                            do {
+                                struct pollfd to_poll[1];
+
+                                ret = wolfSSL_accept(ssl);
+                                err = wolfSSL_get_error(ssl, ret);
+                                if (err == WOLFSSL_ERROR_WANT_READ) {
+                                    to_poll[0].fd = sfd;
+                                    to_poll[0].events = POLLIN;
+                                    poll(to_poll, 1, 500);
+                                }
+                                maxRetries--;
+                            } while ((err == WOLFSSL_ERROR_WANT_READ || err == WOLFSSL_ERROR_WANT_WRITE)
+                                     && maxRetries > 0);
+                        }
+                    }
+#endif
                 }
                 ssl_v = (void*) ssl;
 #endif
@@ -3640,7 +3711,7 @@ static int server_socket(const char *interface,
                 fprintf(stderr, "failed to create listening connection\n");
                 exit(EXIT_FAILURE);
             }
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
             listen_conn_add->ssl_enabled = ssl_enabled;
 #else
             assert(ssl_enabled == false);
@@ -3660,7 +3731,7 @@ static int server_sockets(int port, enum network_transport transport,
                           FILE *portnumber_file) {
     bool ssl_enabled = false;
 
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     const char *notls = "notls";
     ssl_enabled = settings.ssl_enabled;
 #endif
@@ -3684,7 +3755,7 @@ static int server_sockets(int port, enum network_transport transport,
             p = strtok_r(NULL, ";,", &b)) {
             uint64_t conntag = 0;
             int the_port = port;
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
             ssl_enabled = settings.ssl_enabled;
             // "notls" option is valid only when memcached is run with SSL enabled.
             if (strncmp(p, notls, strlen(notls)) == 0) {
@@ -4004,7 +4075,7 @@ static void usage(void) {
 #endif /* #ifndef DISABLE_UNIX_SOCKET */
     printf("-A, --enable-shutdown     enable ascii \"shutdown\" command\n");
     printf("-l, --listen=<addr>       interface to listen on (default: INADDR_ANY)\n");
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     printf("                          if TLS/SSL is enabled, 'notls' prefix can be used to\n"
            "                          disable for specific listeners (-l notls:<ip>:<port>) \n");
 #endif
@@ -4056,7 +4127,7 @@ static void usage(void) {
     printf("-e, --memory-file=<file>  (EXPERIMENTAL) mmap a file for item memory.\n"
            "                          use only in ram disks or persistent memory mounts!\n"
            "                          enables restartable cache (stop with SIGUSR1)\n");
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     printf("-Z, --enable-ssl          enable TLS/SSL\n");
 #endif
     printf("-o, --extended            comma separated list of extended options\n"
@@ -4154,7 +4225,7 @@ static void usage(void) {
     printf("   - proxy_uring:         enable IO_URING for proxy backends.\n");
 #endif
 #endif
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     printf("   - ssl_chain_cert:      certificate chain file in PEM format\n"
            "   - ssl_key:             private key, if not part of the -ssl_chain_cert\n"
            "   - ssl_keyformat:       private key format (PEM, DER or ENGINE) (default: PEM)\n");
@@ -4170,7 +4241,7 @@ static void usage(void) {
            "   - ssl_kernel_tls:      enable kernel TLS offload\n"
            "   - ssl_min_version:     minimum protocol version to accept (default: %s)\n",
            ssl_proto_text(settings.ssl_min_version));
-#if defined(TLS1_3_VERSION)
+#if defined(TLS1_3_VERSION) || defined(WOLFSSL_TLS13)
     printf("                          valid values are 0(%s), 1(%s), 2(%s), or 3(%s).\n",
            ssl_proto_text(TLS1_VERSION), ssl_proto_text(TLS1_1_VERSION),
            ssl_proto_text(TLS1_2_VERSION), ssl_proto_text(TLS1_3_VERSION));
@@ -4181,7 +4252,11 @@ static void usage(void) {
 #endif
     verify_default("ssl_keyformat", settings.ssl_keyformat == SSL_FILETYPE_PEM);
     verify_default("ssl_verify_mode", settings.ssl_verify_mode == SSL_VERIFY_NONE);
+#ifdef TLS
     verify_default("ssl_min_version", settings.ssl_min_version == TLS1_2_VERSION);
+#elif WOLFSSL_MEMCACHED
+    verify_default("ssl_min_version", settings.ssl_min_version == WOLFSSL_TLSV1_2);
+#endif
 #endif
     printf("-N, --napi_ids            number of napi ids. see doc/napi_ids.txt for more details\n");
     return;
@@ -4796,7 +4871,7 @@ int main (int argc, char **argv) {
         DROP_PRIVILEGES,
         RESP_OBJ_MEM_LIMIT,
         READ_BUF_MEM_LIMIT,
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
         SSL_CERT,
         SSL_KEY,
         SSL_VERIFY_MODE,
@@ -4858,7 +4933,7 @@ int main (int argc, char **argv) {
         [DROP_PRIVILEGES] = "drop_privileges",
         [RESP_OBJ_MEM_LIMIT] = "resp_obj_mem_limit",
         [READ_BUF_MEM_LIMIT] = "read_buf_mem_limit",
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
         [SSL_CERT] = "ssl_chain_cert",
         [SSL_KEY] = "ssl_key",
         [SSL_VERIFY_MODE] = "ssl_verify_mode",
@@ -5002,7 +5077,7 @@ int main (int argc, char **argv) {
             break;
         case 'Z':
             /* enable secure communication*/
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
             settings.ssl_enabled = true;
 #else
             fprintf(stderr, "This server is not built with TLS support.\n");
@@ -5460,7 +5535,7 @@ int main (int argc, char **argv) {
                 start_lru_maintainer = false;
                 settings.lru_segmented = false;
                 break;
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
             case SSL_CERT:
                 if (subopts_value == NULL) {
                     fprintf(stderr, "Missing ssl_chain_cert argument\n");
@@ -5560,6 +5635,7 @@ int main (int argc, char **argv) {
                     return 1;
                 }
                 switch (min_version) {
+#ifdef TLS
                     case 0:
                         settings.ssl_min_version = TLS1_VERSION;
                         break;
@@ -5573,6 +5649,24 @@ int main (int argc, char **argv) {
                     case 3:
                         settings.ssl_min_version = TLS1_3_VERSION;
                         break;
+#endif
+#elif WOLFSSL_MEMCACHED
+#ifndef NO_OLD_TLS
+                    case 0:
+                        settings.ssl_min_version = WOLFSSL_TLSV1;
+                        break;
+                    case 1:
+                        settings.ssl_min_version = WOLFSSL_TLSV1_1;
+                        break;
+#endif
+                    case 2:
+                        settings.ssl_min_version = WOLFSSL_TLSV1_2;
+                        break;
+#ifdef WOLFSSL_TLS13
+                    case 3:
+                        settings.ssl_min_version = WOLFSSL_TLSV1_3;
+                        break;
+#endif
 #endif
                     default:
                         fprintf(stderr, "Invalid ssl_min_version. Use help to see valid options.\n");
@@ -5807,7 +5901,7 @@ int main (int argc, char **argv) {
     }
 
 
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     /*
      * Setup SSL if enabled
      */
@@ -5816,9 +5910,11 @@ int main (int argc, char **argv) {
             fprintf(stderr, "ERROR: You cannot enable SSL without a TCP port.\n");
             exit(EX_USAGE);
         }
+#ifdef TLS
         // openssl init methods.
         SSL_load_error_strings();
         SSLeay_add_ssl_algorithms();
+#endif
         // Initiate the SSL context.
         ssl_init();
     }
diff --git a/memcached.h b/memcached.h
index 9bd80b0..dde9517 100644
--- a/memcached.h
+++ b/memcached.h
@@ -59,6 +59,14 @@
 #include <openssl/ssl.h>
 #endif
 
+#ifdef WOLFSSL_MEMCACHED
+#ifndef WOLFSSL_USER_SETTINGS
+#include <wolfssl/options.h>
+#endif
+#include <wolfssl/wolfcrypt/settings.h>
+#include <wolfssl/ssl.h>
+#endif
+
 /* for NAPI pinning feature */
 #ifndef SO_INCOMING_NAPI_ID
 #define SO_INCOMING_NAPI_ID 56
@@ -397,7 +405,7 @@ struct stats {
     uint64_t      extstore_compact_rescues; /* items re-written during compaction */
     uint64_t      extstore_compact_skipped; /* unhit items skipped during compaction */
 #endif
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     uint64_t      ssl_handshake_errors; /* TLS failures at accept/handshake time */
     uint64_t      ssl_new_sessions; /* successfully negotiated new (non-reused) TLS sessions */
 #endif
@@ -507,9 +515,13 @@ struct settings {
     /* start flushing to extstore after memory below this */
     unsigned int ext_global_pool_min;
 #endif
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     bool ssl_enabled; /* indicates whether SSL is enabled */
+#ifdef TLS
     SSL_CTX *ssl_ctx; /* holds the SSL server context which has the server certificate */
+#elif WOLFSSL_MEMCACHED
+    WOLFSSL_CTX *ssl_ctx; /* holds the SSL server context which has the server certificate */
+#endif
     char *ssl_chain_cert; /* path to the server SSL chain certificate */
     char *ssl_key; /* path to the server key */
     int ssl_verify_mode; /* client certificate verify mode */
@@ -709,7 +721,7 @@ typedef struct {
 #endif
     logger *l;                  /* logger buffer */
     void *lru_bump_buf;         /* async LRU bump buffer */
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     char   *ssl_wbuf;
 #endif
     int napi_id;                /* napi id associated with this thread */
@@ -791,8 +803,12 @@ struct conn {
     bool close_after_write; /** flush write then move to close connection */
     bool rbuf_malloced; /** read buffer was malloc'ed for ascii mget, needs free() */
     bool item_malloced; /** item for conn_nread state is a temporary malloc */
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
 #ifdef TLS
-    SSL    *ssl;
+    SSL     *ssl;
+#elif WOLFSSL_MEMCACHED
+    WOLFSSL *ssl;
+#endif
     char   *ssl_wbuf;
     bool ssl_enabled;
 #endif
diff --git a/proto_bin.c b/proto_bin.c
index ef82de0..76b8954 100644
--- a/proto_bin.c
+++ b/proto_bin.c
@@ -10,6 +10,9 @@
 #ifdef TLS
 #include "tls.h"
 #endif
+#ifdef WOLFSSL_MEMCACHED
+#include "wolfssl.h"
+#endif
 #include <string.h>
 #include <stdlib.h>
 
diff --git a/proto_text.c b/proto_text.c
index d316792..fa51e19 100644
--- a/proto_text.c
+++ b/proto_text.c
@@ -15,6 +15,9 @@
 #ifdef TLS
 #include "tls.h"
 #endif
+#ifdef WOLFSSL_MEMCACHED
+#include "wolfssl.h"
+#endif
 #include <string.h>
 #include <stdlib.h>
 
@@ -2726,7 +2729,7 @@ static void process_lru_crawler_command(conn *c, token_t *tokens, const size_t n
         out_string(c, "ERROR");
     }
 }
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
 static void process_refresh_certs_command(conn *c, token_t *tokens, const size_t ntokens) {
     set_noreply_maybe(c, tokens, ntokens);
     char *errmsg = NULL;
@@ -2948,7 +2951,7 @@ void process_command_ascii(conn *c, char *command) {
         WANT_TOKENS_MIN(ntokens, 3);
         process_extstore_command(c, tokens, ntokens);
 #endif
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     } else if (strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
         process_refresh_certs_command(c, tokens, ntokens);
 #endif
diff --git a/testapp.c b/testapp.c
index 387a847..393adcf 100644
--- a/testapp.c
+++ b/testapp.c
@@ -29,6 +29,13 @@
 #ifdef TLS
 #include <openssl/ssl.h>
 #endif
+#ifdef WOLFSSL_MEMCACHED
+#ifndef WOLFSSL_USER_SETTINGS
+#include <wolfssl/options.h>
+#endif
+#include <wolfssl/wolfcrypt/settings.h>
+#include <wolfssl/ssl.h>
+#endif
 
 #define TMP_TEMPLATE "/tmp/test_file.XXXXXXX"
 
@@ -39,6 +46,10 @@ struct conn {
 #ifdef TLS
     SSL_CTX   *ssl_ctx;
     SSL    *ssl;
+#endif
+#ifdef WOLFSSL_MEMCACHED
+    WOLFSSL_CTX *ssl_ctx;
+    WOLFSSL     *ssl;
 #endif
     ssize_t (*read)(struct conn  *c, void *buf, size_t count);
     ssize_t (*write)(struct conn *c, const void *buf, size_t count);
@@ -48,7 +59,7 @@ hash_func hash;
 
 static ssize_t tcp_read(struct conn *c, void *buf, size_t count);
 static ssize_t tcp_write(struct conn *c, const void *buf, size_t count);
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
 static ssize_t ssl_read(struct conn *c, void *buf, size_t count);
 static ssize_t ssl_write(struct conn *c, const void *buf, size_t count);
 #endif
@@ -73,6 +84,31 @@ ssize_t ssl_write(struct conn *c, const void *buf, size_t count) {
     return SSL_write(c->ssl, buf, count);
 }
 #endif
+#ifdef WOLFSSL_MEMCACHED
+ssize_t ssl_read(struct conn *c, void *buf, size_t count) {
+    int ret = -1;
+
+    assert(c != NULL);
+    ret = wolfSSL_read(c->ssl, buf, count);
+    if (ret < 0) {
+        ret = wolfSSL_get_error(c->ssl, ret);
+    }
+
+    return ret;
+}
+
+ssize_t ssl_write(struct conn *c, const void *buf, size_t count) {
+    int ret = -1;
+
+    assert(c != NULL);
+    ret = wolfSSL_write(c->ssl, buf, count);
+    if (ret < 0) {
+        ret = wolfSSL_get_error(c->ssl, ret);
+    }
+
+    return ret;
+}
+#endif
 
 static pid_t server_pid;
 static in_port_t port;
@@ -89,6 +125,14 @@ static void close_conn(void) {
     }
     if (con->ssl_ctx)
         SSL_CTX_free(con->ssl_ctx);
+#endif
+#ifdef WOLFSSL_MEMCACHED
+    if (con->ssl) {
+        wolfSSL_shutdown(con->ssl);
+        wolfSSL_free(con->ssl);
+    }
+    if (con->ssl_ctx)
+        wolfSSL_CTX_free(con->ssl_ctx);
 #endif
     if (con->sock > 0) close(con->sock);
     free(con);
@@ -529,7 +573,7 @@ static pid_t start_server(in_port_t *port_out, bool daemon, int timeout) {
         argv[arg++] = "-1";
         argv[arg++] = "-U";
         argv[arg++] = "0";
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
         if (enable_ssl) {
             argv[arg++] = "-Z";
             argv[arg++] = "-o";
@@ -718,6 +762,44 @@ static struct conn *connect_server(const char *hostname, in_port_t port,
         c->read = ssl_read;
         c->write = ssl_write;
     } else
+#endif
+#ifdef WOLFSSL_MEMCACHED
+    if (sock > 0 && ssl) {
+        c->ssl_ctx = wolfSSL_CTX_new(wolfSSLv23_client_method());
+        if (c->ssl_ctx == NULL) {
+            fprintf(stderr, "Failed to create the SSL context.\n");
+            close(sock);
+            sock = -1;
+        }
+        c->ssl = wolfSSL_new(c->ssl_ctx);
+        if (c->ssl == NULL) {
+            fprintf(stderr, "Failed to create the SSL object.\n");
+            close(sock);
+            sock = -1;
+        }
+        wolfSSL_set_fd (c->ssl, c->sock);
+        int ret = -1;
+        ret = wolfSSL_CTX_load_verify_locations(c->ssl_ctx, "./t/cacert.pem", NULL);
+        if (ret != WOLFSSL_SUCCESS) {
+            int err = wolfSSL_get_error(c->ssl, ret);
+            fprintf(stderr, "SSL CA cert load failed with error code : %s\n",
+                    wolfSSL_ERR_reason_error_string(err));
+            close(sock);
+            sock = -1;
+        }
+        ret = wolfSSL_connect(c->ssl);
+        if (ret != WOLFSSL_SUCCESS) {
+            int err = wolfSSL_get_error(c->ssl, ret);
+            if (err != WOLFSSL_ERROR_WANT_READ && err != WOLFSSL_ERROR_WANT_WRITE) {
+                fprintf(stderr, "SSL connection failed with error code : %s\n",
+                    wolfSSL_ERR_reason_error_string(err));
+                close(sock);
+                sock = -1;
+            }
+        }
+        c->read = ssl_read;
+        c->write = ssl_write;
+    } else
 #endif
     {
         c->read = tcp_read;
@@ -778,6 +860,13 @@ static void send_ascii_command(const char *buf) {
 
     do {
         ssize_t nw = con->write((void*)con, ptr + offset, len - offset);
+#ifdef WOLFSSL_MEMCACHED
+        if (enable_ssl && nw < 0) {
+            fprintf(stderr, "Failed to write: %s\n",
+                    wolfSSL_ERR_reason_error_string(nw));
+            abort();
+        } else
+#endif
         if (nw == -1) {
             if (errno != EINTR) {
                 fprintf(stderr, "Failed to write: %s\n", strerror(errno));
@@ -800,6 +889,13 @@ static void read_ascii_response(char *buffer, size_t size) {
     bool need_more = true;
     do {
         ssize_t nr = con->read(con, buffer + offset, 1);
+#ifdef WOLFSSL_MEMCACHED
+        if (enable_ssl && nr < 0) {
+            fprintf(stderr, "Failed to read: %s\n",
+                    wolfSSL_ERR_reason_error_string(nr));
+            abort();
+        } else
+#endif
         if (nr == -1) {
             if (errno != EINTR) {
                 fprintf(stderr, "Failed to read: %s\n", strerror(errno));
@@ -985,6 +1081,13 @@ static void safe_send(const void* buf, size_t len, bool hickup)
             }
         }
         ssize_t nw = con->write(con, ptr + offset, num_bytes);
+#ifdef WOLFSSL_MEMCACHED
+        if (enable_ssl && nw < 0) {
+            fprintf(stderr, "Failed to write: %s\n",
+                    wolfSSL_ERR_reason_error_string(nw));
+            abort();
+        } else
+#endif
         if (nw == -1) {
             if (errno != EINTR) {
                 fprintf(stderr, "Failed to write: %s\n", strerror(errno));
@@ -1006,6 +1109,13 @@ static bool safe_recv(void *buf, size_t len) {
     off_t offset = 0;
     do {
         ssize_t nr = con->read(con, ((char*)buf) + offset, len - offset);
+#ifdef WOLFSSL_MEMCACHED
+        if (enable_ssl && nr < 0) {
+            fprintf(stderr, "Failed to read: %s\n",
+                    wolfSSL_ERR_reason_error_string(nr));
+            abort();
+        } else
+#endif
         if (nr == -1) {
             if (errno != EINTR) {
                 fprintf(stderr, "Failed to read: %s\n", strerror(errno));
@@ -2183,6 +2293,14 @@ static enum test_return test_issue_101(void) {
         bool more = true;
         do {
             ssize_t err = conns[ii]->write(conns[ii], command, cmdlen);
+#ifdef WOLFSSL_MEMCACHED
+            if (enable_ssl && err == cmdlen) {
+                more = false;
+            } else if (enable_ssl && err < 0) {
+                ret = TEST_FAIL;
+                goto cleanup;
+            } else
+#endif
             if (err == -1) {
                 switch (errno) {
                 case EINTR:
@@ -2228,6 +2346,14 @@ static enum test_return test_issue_101(void) {
         }
         if (c->ssl_ctx)
             SSL_CTX_free(c->ssl_ctx);
+#endif
+#ifdef WOLFSSL_MEMCACHED
+        if (c->ssl) {
+            wolfSSL_shutdown(c->ssl);
+            wolfSSL_free(c->ssl);
+        }
+        if (c->ssl_ctx)
+            wolfSSL_CTX_free(c->ssl_ctx);
 #endif
         if (c->sock > 0) close(c->sock);
         free(conns[ii]);
@@ -2324,6 +2450,12 @@ int main(int argc, char **argv)
         SSL_load_error_strings();
         enable_ssl = true;
     }
+#endif
+#ifdef WOLFSSL_MEMCACHED
+    if (getenv("SSL_TEST") != NULL) {
+        wolfSSL_Init();
+        enable_ssl = true;
+    }
 #endif
     /* Initialized directly instead of using hash_init to avoid pulling in
        the definition of settings struct from memcached.h */
diff --git a/thread.c b/thread.c
index 3ca1da3..b52f672 100644
--- a/thread.c
+++ b/thread.c
@@ -28,6 +28,13 @@
 #ifdef TLS
 #include <openssl/ssl.h>
 #endif
+#ifdef WOLFSSL_MEMCACHED
+#ifndef WOLFSSL_USER_SETTINGS
+#include <wolfssl/options.h>
+#endif
+#include <wolfssl/wolfcrypt/settings.h>
+#include <wolfssl/ssl.h>
+#endif
 
 #define ITEMS_PER_ALLOC 64
 
@@ -469,7 +476,7 @@ static void setup_thread(LIBEVENT_THREAD *me) {
         fprintf(stderr, "Failed to create IO object cache\n");
         exit(EXIT_FAILURE);
     }
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
     if (settings.ssl_enabled) {
         me->ssl_wbuf = (char *)malloc((size_t)settings.ssl_wbuf_size);
         if (me->ssl_wbuf == NULL) {
@@ -585,13 +592,19 @@ static void thread_libevent_process(evutil_socket_t fd, short which, void *arg)
                             SSL_shutdown(item->ssl);
                             SSL_free(item->ssl);
                         }
+#endif
+#ifdef WOLFSSL_MEMCACHED
+                        if (item->ssl) {
+                            wolfSSL_shutdown(item->ssl);
+                            wolfSSL_free(item->ssl);
+                        }
 #endif
                         close(item->sfd);
                     }
                 } else {
                     c->thread = me;
                     conn_io_queue_setup(c);
-#ifdef TLS
+#if defined(TLS) || defined(WOLFSSL_MEMCACHED)
                     if (settings.ssl_enabled && c->ssl != NULL) {
                         assert(c->thread && c->thread->ssl_wbuf);
                         c->ssl_wbuf = c->thread->ssl_wbuf;
diff --git a/wolfssl.c b/wolfssl.c
new file mode 100644
index 0000000..0705ef9
--- /dev/null
+++ b/wolfssl.c
@@ -0,0 +1,314 @@
+#include "memcached.h"
+
+#ifdef WOLFSSL_MEMCACHED
+
+#include "wolfssl.h"
+#include <string.h>
+#include <sysexits.h>
+#include <sys/param.h>
+#ifndef WOLFSSL_USER_SETTINGS
+#include <wolfssl/options.h>
+#endif
+#include <wolfssl/wolfcrypt/settings.h>
+#include <wolfssl/ssl.h>
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 4096
+#endif
+
+static pthread_mutex_t wolfssl_ctx_lock = PTHREAD_MUTEX_INITIALIZER;
+
+const unsigned ERROR_MSG_SIZE = 64;
+const size_t SSL_ERROR_MSG_SIZE = 256;
+const unsigned MAX_RETRY_COUNT = 5;
+
+void SSL_LOCK() {
+    pthread_mutex_lock(&(wolfssl_ctx_lock));
+}
+
+void SSL_UNLOCK(void) {
+    pthread_mutex_unlock(&(wolfssl_ctx_lock));
+}
+
+/*
+ * Reads decrypted data from the underlying BIO read buffers,
+ * which reads from the socket.
+ */
+ssize_t ssl_read(conn *c, void *buf, size_t count) {
+    int ret = -1, err = 0;
+
+    assert (c != NULL);
+    /* TODO : document the state machine interactions for SSL_read with
+        non-blocking sockets/ SSL re-negotiations
+    */
+
+    ret = wolfSSL_read(c->ssl, buf, count);
+    err = wolfSSL_get_error(c->ssl, ret);
+    if (err == WOLFSSL_ERROR_WANT_READ) {
+        ret = -1;
+        errno = EWOULDBLOCK;
+    }
+
+    return ret;
+}
+
+/*
+ * SSL sendmsg implementation. Perform a SSL_write.
+ */
+ssize_t ssl_sendmsg(conn *c, struct msghdr *msg, int flags) {
+    assert (c != NULL);
+    size_t buf_remain = settings.ssl_wbuf_size;
+    size_t bytes = 0;
+    size_t to_copy;
+    int i;
+
+    // ssl_wbuf is pointing to the buffer allocated in the worker thread.
+    assert(c->ssl_wbuf);
+    // TODO: allocate a fix buffer in crawler/logger if they start using
+    // the sendmsg method. Also, set c->ssl_wbuf  when the side thread
+    // start owning the connection and reset the pointer in
+    // conn_worker_readd.
+    // Currently this connection would not be served by a different thread
+    // than the one it's assigned.
+    assert(pthread_equal(c->thread->thread_id, pthread_self()) != 0);
+
+    char *bp = c->ssl_wbuf;
+    for (i = 0; i < msg->msg_iovlen; i++) {
+        size_t len = msg->msg_iov[i].iov_len;
+        to_copy = len < buf_remain ? len : buf_remain;
+
+        memcpy(bp + bytes, (void*)msg->msg_iov[i].iov_base, to_copy);
+        buf_remain -= to_copy;
+        bytes += to_copy;
+        if (buf_remain == 0)
+            break;
+    }
+    /* TODO : document the state machine interactions for SSL_write with
+        non-blocking sockets/ SSL re-negotiations
+    */
+    return ssl_write(c, c->ssl_wbuf, bytes);
+}
+
+/*
+ * Writes data to the underlying BIO write buffers,
+ * which encrypt and write them to the socket.
+ */
+ssize_t ssl_write(conn *c, void *buf, size_t count) {
+    int ret = -1, err = 0;
+    unsigned retry = 0;
+
+    assert (c != NULL);
+
+    do {
+        ret = wolfSSL_write(c->ssl, buf, count);
+        err = wolfSSL_get_error(c->ssl, ret);
+        if (err == WOLFSSL_ERROR_WANT_WRITE) {
+            usleep(500);
+        }
+        retry++;
+    } while (err == WOLFSSL_ERROR_WANT_WRITE && retry < MAX_RETRY_COUNT);
+    if (err == WOLFSSL_ERROR_WANT_WRITE) {
+        errno = EWOULDBLOCK;
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/*
+ * Prints an SSL error into the buff, if there's any.
+ */
+static void print_ssl_error(char *buff, size_t len) {
+    unsigned long err;
+    if ((err = wolfSSL_ERR_get_error()) != 0) {
+        wolfSSL_ERR_error_string_n(err, buff, len);
+    }
+}
+
+/*
+ * Loads server certificates to the SSL context and validate them.
+ * @return whether certificates are successfully loaded and verified or not.
+ * @param error_msg contains the error when unsuccessful.
+ */
+static bool load_server_certificates(char **errmsg) {
+    bool success = false;
+
+    const size_t CRLF_NULLCHAR_LEN = 3;
+    char *error_msg = malloc(MAXPATHLEN + ERROR_MSG_SIZE +
+        SSL_ERROR_MSG_SIZE);
+    size_t errmax = MAXPATHLEN + ERROR_MSG_SIZE + SSL_ERROR_MSG_SIZE -
+        CRLF_NULLCHAR_LEN;
+
+    if (error_msg == NULL) {
+        *errmsg = NULL;
+        return false;
+    }
+
+    if (settings.ssl_ctx == NULL) {
+        snprintf(error_msg, errmax, "Error TLS not enabled\r\n");
+        *errmsg = error_msg;
+        return false;
+    }
+
+    char *ssl_err_msg = malloc(SSL_ERROR_MSG_SIZE);
+    if (ssl_err_msg == NULL) {
+        free(error_msg);
+        *errmsg = NULL;
+        return false;
+    }
+    bzero(ssl_err_msg, SSL_ERROR_MSG_SIZE);
+    size_t err_msg_size = 0;
+
+    SSL_LOCK();
+    if (!wolfSSL_CTX_use_certificate_chain_file(settings.ssl_ctx,
+        settings.ssl_chain_cert)) {
+        print_ssl_error(ssl_err_msg, SSL_ERROR_MSG_SIZE);
+        err_msg_size = snprintf(error_msg, errmax, "Error loading the certificate chain: "
+            "%s : %s", settings.ssl_chain_cert, ssl_err_msg);
+    } else if (!wolfSSL_CTX_use_PrivateKey_file(settings.ssl_ctx, settings.ssl_key,
+                                        settings.ssl_keyformat)) {
+        print_ssl_error(ssl_err_msg, SSL_ERROR_MSG_SIZE);
+        err_msg_size = snprintf(error_msg, errmax, "Error loading the key: %s : %s",
+            settings.ssl_key, ssl_err_msg);
+    } else if (!wolfSSL_CTX_check_private_key(settings.ssl_ctx)) {
+        print_ssl_error(ssl_err_msg, SSL_ERROR_MSG_SIZE);
+        err_msg_size = snprintf(error_msg, errmax, "Error validating the certificate: %s",
+            ssl_err_msg);
+    } else if (settings.ssl_ca_cert) {
+        if (!wolfSSL_CTX_load_verify_locations(settings.ssl_ctx,
+          settings.ssl_ca_cert, NULL)) {
+            print_ssl_error(ssl_err_msg, SSL_ERROR_MSG_SIZE);
+            err_msg_size = snprintf(error_msg, errmax,
+              "Error loading the CA certificate: %s : %s",
+              settings.ssl_ca_cert, ssl_err_msg);
+        } else {
+            /*wolfSSL_CTX_set_client_CA_list(settings.ssl_ctx,
+              wolfSSL_load_client_CA_file(settings.ssl_ca_cert));*/
+            fprintf(stderr, "Warning: wolfSSL does not currently support setting client CA list.\n");
+            success = true;
+        }
+    } else {
+        success = true;
+    }
+    SSL_UNLOCK();
+    free(ssl_err_msg);
+    if (success) {
+        settings.ssl_last_cert_refresh_time = current_time;
+        free(error_msg);
+    } else {
+        *errmsg = error_msg;
+        error_msg += (err_msg_size >= errmax ? errmax - 1: err_msg_size);
+        snprintf(error_msg, CRLF_NULLCHAR_LEN, "\r\n");
+        // Print if there are more errors and drain the queue.
+        wc_ERR_print_errors_fp(stderr);
+    }
+    return success;
+}
+
+/*
+ * Verify SSL settings and initiates the SSL context.
+ */
+int ssl_init(void) {
+    assert(settings.ssl_enabled);
+
+    if (wolfSSL_Init() != WOLFSSL_SUCCESS) {
+        fprintf(stderr, "Failed to initialize wolfSSL.");
+        exit(EX_SOFTWARE);
+    }
+
+    // SSL context for the process. All connections will share one
+    // process level context.
+    settings.ssl_ctx = wolfSSL_CTX_new(wolfTLS_server_method());
+
+    wolfSSL_CTX_SetMinVersion(settings.ssl_ctx, settings.ssl_min_version);
+
+    // Unlike OpenSSL, wolfSSL does not enable auto retry by default.
+    // When using a nonblocking socket, the application is required to
+    // retry calls until success.  Auto retry mode lets wolfSSL handle
+    // this for reads.
+    wolfSSL_CTX_set_mode(settings.ssl_ctx, SSL_MODE_AUTO_RETRY);
+
+    // The server certificate, private key and validations.
+    char *error_msg;
+    if (!load_server_certificates(&error_msg)) {
+        fprintf(stderr, "%s", error_msg);
+        free(error_msg);
+        exit(EX_USAGE);
+    }
+
+    // The verification mode of client certificate, default is SSL_VERIFY_PEER.
+    wolfSSL_CTX_set_verify(settings.ssl_ctx, settings.ssl_verify_mode, NULL);
+    if (settings.ssl_ciphers && !wolfSSL_CTX_set_cipher_list(settings.ssl_ctx,
+                                                    settings.ssl_ciphers)) {
+        fprintf(stderr, "Error setting the provided cipher(s): %s\n",
+                settings.ssl_ciphers);
+        exit(EX_USAGE);
+    }
+
+    // Optional session caching; default disabled.
+    if (settings.ssl_session_cache) {
+        wolfSSL_CTX_sess_set_new_cb(settings.ssl_ctx, ssl_new_session_callback);
+        wolfSSL_CTX_set_session_cache_mode(settings.ssl_ctx, WOLFSSL_SESS_CACHE_SERVER);
+        wolfSSL_CTX_set_session_id_context(settings.ssl_ctx,
+                                           (const unsigned char *) SESSION_ID_CONTEXT,
+                                           strlen(SESSION_ID_CONTEXT));
+    } else {
+        wolfSSL_CTX_set_session_cache_mode(settings.ssl_ctx, SSL_SESS_CACHE_OFF);
+    }
+
+    // wolfSSL does not support kTLS.
+
+    // wolfSSL does not support disabling renegotiation at runtime.
+    // It is off by default, and must be enabled by the calling application
+    // or it is not used.
+
+    // Release TLS read/write buffers of idle connections
+    // wolfSSL does not currently support SSL_MODE_RELEASE_BUFFERS.
+    /*wolfSSL_CTX_set_mode(settings.ssl_ctx, SSL_MODE_RELEASE_BUFFERS);*/
+
+    return 0;
+}
+
+/*
+ * This method is invoked with every new successfully negotiated SSL session,
+ * when server-side session caching is enabled. Note that this method is not
+ * invoked when a session is reused.
+ */
+int ssl_new_session_callback(WOLFSSL *s, WOLFSSL_SESSION *sess) {
+    STATS_LOCK();
+    stats.ssl_new_sessions++;
+    STATS_UNLOCK();
+
+    return 0;
+}
+
+bool refresh_certs(char **errmsg) {
+    int ret = -1;
+
+    ret = wolfSSL_CTX_UnloadCAs(settings.ssl_ctx);
+    if (ret != WOLFSSL_SUCCESS) {
+        fprintf(stderr, "Error unloading CA certs: %s.\n",
+                wolfSSL_ERR_reason_error_string(ret));
+        return false;
+    }
+
+    return load_server_certificates(errmsg);
+}
+
+const char *ssl_proto_text(int version) {
+    switch (version) {
+        case WOLFSSL_TLSV1:
+            return "tlsv1.0";
+        case WOLFSSL_TLSV1_1:
+            return "tlsv1.1";
+        case WOLFSSL_TLSV1_2:
+            return "tlsv1.2";
+#if defined(TLS1_3_VERSION)
+        case WOLFSSL_TLSV1_3:
+            return "tlsv1.3";
+#endif
+        default:
+            return "unknown";
+    }
+}
+#endif
diff --git a/wolfssl.h b/wolfssl.h
new file mode 100644
index 0000000..aac5a16
--- /dev/null
+++ b/wolfssl.h
@@ -0,0 +1,19 @@
+#ifndef WOLFSSL_H
+#define WOLFSSL_H
+
+/* constant session ID context for application-level SSL session scoping.
+ * used in server-side SSL session caching, when enabled. */
+#define SESSION_ID_CONTEXT "memcached"
+
+void SSL_LOCK(void);
+void SSL_UNLOCK(void);
+ssize_t ssl_read(conn *c, void *buf, size_t count);
+ssize_t ssl_sendmsg(conn *c, struct msghdr *msg, int flags);
+ssize_t ssl_write(conn *c, void *buf, size_t count);
+
+int ssl_init(void);
+bool refresh_certs(char **errmsg);
+int ssl_new_session_callback(WOLFSSL *s, WOLFSSL_SESSION *sess);
+const char *ssl_proto_text(int version);
+
+#endif
