diff --git a/configure.ac b/configure.ac
index 9c2b2b6..9daa432 100644
--- a/configure.ac
+++ b/configure.ac
@@ -437,26 +437,63 @@ find_ssl_dir() { :
     check_ssl_dir "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift-migrator/sdk/MacOSX.sdk/usr"
 }
 
-SSLDIR=""
-AC_MSG_CHECKING([for TLS directory])
-AC_ARG_WITH(ssl,
-[  --with-ssl=DIR          location of installed TLS libraries/include files],
-    [check_ssl_dir "$withval"],
-    [find_ssl_dir]
-)
-if test -z "$SSLDIR"; then
-AC_MSG_RESULT([not found])
-AC_MSG_ERROR([
-Could not find your TLS library installation dir
-Use --with-ssl option to fix this problem
-])
+AC_ARG_ENABLE([wolfssl],
+    [  --enable-wolfssl        Enable stunnel with wolfSSL (default: disabled)],
+    [ ENABLED_WOLFSSL=$enableval ],
+    [ ENABLED_WOLFSSL=$no ])
+
+if test "x$ENABLED_WOLFSSL" = "xyes"
+then
+    AM_CFLAGS="$AM_CFLAGS -DWITH_WOLFSSL"
+    SSLDIR="/usr/local"
+    AC_DEFINE([WITH_WOLFSSL], [1],
+    [Define to 1 if you using WOLFSSL header file.])
+fi
+
+AM_CONDITIONAL([WOLFSSL], test "x$ENABLED_WOLFSSL" = "xyes")
+
+AC_ARG_ENABLE([wolfssldebug],
+    [  --enable-wolfssldebug   Enable wolfSSL debugging information (default: disabled)],
+    [ ENABLED_WOLFSSLDEBUG=$enableval ],
+    [ ENABLED_WOLFSSLDEBUG=$no ])
+if test "x$ENABLED_WOLFSSLDEBUG" = "xyes"
+then
+    AM_CFLAGS="$AM_CFLAGS -DWITH_WOLFSSL_DEBUG"
+    AC_DEFINE([WOLFSSL_DEBUG_ON], [1],
+    [Define to 1 to enable WOLFSSL debug messages.])
+fi
+
+AM_CONDITIONAL([WOLFSSL_DEBUG_ON], test "x$ENABLED_WOLFSSLDEBUG" = "xyes")
+
+if test "x$ENABLED_WOLFSSL" = "xno"
+then
+    SSLDIR=""
+    AC_MSG_CHECKING([for TLS directory])
+    AC_ARG_WITH(ssl,
+    [  --with-ssl=DIR          location of installed SSL libraries/include files],
+        [check_ssl_dir "$withval"],
+        [find_ssl_dir]
+    )
+    if test -z "$SSLDIR"; then
+    AC_MSG_RESULT([not found])
+    AC_MSG_ERROR([
+    Could not find your TLS library installation dir
+    Use --with-ssl option to fix this problem
+    ]) 
+    fi
 fi
 AC_MSG_RESULT([$SSLDIR])
 AC_SUBST([SSLDIR])
 AC_DEFINE_UNQUOTED([SSLDIR], ["$SSLDIR"], [TLS directory])
 
+if test "x$ENABLED_WOLFSSL" = "xyes"
+then
+valid_CPPFLAGS="$CPPFLAGS"; CPPFLAGS="$CPPFLAGS -I$SSLDIR/include -I$SSLDIR/include/wolfssl"
+valid_LIBS="$LIBS"; LIBS="$LIBS -L$SSLDIR/lib64 -L$SSLDIR/lib -lwolfssl"
+else
 valid_CPPFLAGS="$CPPFLAGS"; CPPFLAGS="$CPPFLAGS -I$SSLDIR/include"
 valid_LIBS="$LIBS"; LIBS="$LIBS -L$SSLDIR/lib64 -L$SSLDIR/lib -lssl -lcrypto"
+fi
 
 if test "x$use_fips" = "xauto"; then
     AC_CHECK_FUNCS(FIPS_mode_set, [
diff --git a/src/Makefile.am b/src/Makefile.am
index d30842f..68d9d5a 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -30,12 +30,20 @@ CLEANFILES = stunnel3
 stunnel_CPPFLAGS = -I$(SYSROOT)/usr/kerberos/include
 
 # Additional preprocesor definitions
+if WOLFSSL
+stunnel_CPPFLAGS += -I$(SSLDIR)/include/wolfssl -I$(SSLDIR)/include
+else
 stunnel_CPPFLAGS += -I$(SSLDIR)/include
+endif
 stunnel_CPPFLAGS += -DLIBDIR='"$(pkglibdir)"'
 stunnel_CPPFLAGS += -DCONFDIR='"$(sysconfdir)/stunnel"'
 
 # TLS library
+if WOLFSSL
+stunnel_LDFLAGS = -L$(SSLDIR)/lib64 -L$(SSLDIR)/lib -lwolfssl
+else
 stunnel_LDFLAGS = -L$(SSLDIR)/lib64 -L$(SSLDIR)/lib -lssl -lcrypto
+endif
 
 # stunnel3 script
 edit = sed \
@@ -53,8 +61,13 @@ libstunnel_la_LDFLAGS = -avoid-version
 # Win32 executables                                                           #
 ###############################################################################
 
+if WOLFSSL
+mingw:
+	$(MAKE) -f $(srcdir)/mingw_wolfssl.mk srcdir=$(srcdir) win32_arch=win32 win32_targetcpu=i686 win32_mingw=mingw
+else
 mingw:
 	$(MAKE) -f $(srcdir)/mingw.mk srcdir=$(srcdir) win32_arch=win32 win32_targetcpu=i686 win32_mingw=mingw
+endif
 
 mingw64:
 	$(MAKE) -f $(srcdir)/mingw.mk srcdir=$(srcdir) win32_arch=win64 win32_targetcpu=x86_64 win32_mingw=mingw64
diff --git a/src/client.c b/src/client.c
index 7825e04..6bbe722 100644
--- a/src/client.c
+++ b/src/client.c
@@ -626,7 +626,9 @@ NOEXPORT void ssl_start(CLI *c) {
             if(!c->opt->option.client)
                 SSL_CTX_add_session(c->opt->ctx, sess);
         }
+    #ifndef WITH_WOLFSSL
         SSL_SESSION_free(sess);
+    #endif
     }
 }
 
@@ -1517,7 +1519,9 @@ NOEXPORT SOCKET connect_remote(CLI *c) {
                 SSL_SESSION *sess=SSL_get1_session(c->ssl);
                 if(sess) {
                     idx_cache_save(sess, &c->connect_addr.addr[c->idx]);
+                #ifndef WITH_WOLFSSL
                     SSL_SESSION_free(sess);
+                #endif
                 }
             }
             print_bound_address(c);
@@ -1577,7 +1581,9 @@ NOEXPORT unsigned idx_cache_retrieve(CLI *c) {
                 len=addr_len(ptr);
                 memcpy(&addr, ptr, (size_t)len);
                 CRYPTO_THREAD_unlock(stunnel_locks[LOCK_ADDR]);
+            #ifndef WITH_WOLFSSL
                 SSL_SESSION_free(sess);
+            #endif
                 /* address was copied, ptr itself is no longer valid */
                 for(i=0; i<c->connect_addr.num; ++i) {
                     if(addr_len(&c->connect_addr.addr[i])==len &&
@@ -1594,7 +1600,9 @@ NOEXPORT unsigned idx_cache_retrieve(CLI *c) {
                 str_free(addr_txt);
             } else {
                 CRYPTO_THREAD_unlock(stunnel_locks[LOCK_ADDR]);
+            #ifndef WITH_WOLFSSL
                 SSL_SESSION_free(sess);
+            #endif
                 s_log(LOG_NOTICE, "persistence: No cached address found");
             }
         }
@@ -1748,7 +1756,9 @@ NOEXPORT int redirect(CLI *c) {
     if(!sess)
         return 1; /* no TLS session -> always redirect */
     ex_data=SSL_SESSION_get_ex_data(sess, index_session_authenticated);
+#ifndef WITH_WOLFSSL
     SSL_SESSION_free(sess);
+#endif
     return ex_data == NULL;
 }
 
diff --git a/src/common.h b/src/common.h
index 929cfa7..cd30b22 100644
--- a/src/common.h
+++ b/src/common.h
@@ -47,15 +47,22 @@
 #define LIBWRAP_CLIENTS 5
 
 /* CPU stack size */
-#define DEFAULT_STACK_SIZE 65536
+#ifdef WITH_WOLFSSL
+    /* Default option for wolfssl is Tom's fastmath with timing resistance
+     * which providers far greater security. This can be reduced to
+     * 65536 if not using TFM timing resistance. */
+    #define DEFAULT_STACK_SIZE 131072
+#else
+    #define DEFAULT_STACK_SIZE 65536
+#endif
 /* #define DEBUG_STACK_SIZE */
 
 /* I/O buffer size: 18432 (0x4800) is the maximum size of TLS record payload */
 #define BUFFSIZE 18432
 
 /* how many bytes of random input to read from files for PRNG */
-/* security margin is huge to compensate for flawed entropy */
-#define RANDOM_BYTES 1024
+/* OpenSSL likes at least 128 bits, so 64 bytes seems plenty. */
+#define RANDOM_BYTES 64
 
 /**************************************** debugging */
 
@@ -409,6 +416,20 @@ extern char *sys_errlist[];
 #define S_ISREG(m) (((m)&S_IFMT)==S_IFREG)
 #endif
 
+/**************************************** wolfSSL headers */
+#ifdef WITH_WOLFSSL
+#include <wolfssl/options.h>
+#include <wolfssl/openssl/ssl.h>
+#include <wolfssl/wolfcrypt/wc_port.h>
+#include <wolfssl/wolfcrypt/coding.h>
+#ifdef WOLFSSL_DEBUG_ON
+#include <wolfssl/wolfcrypt/logging.h>
+#endif /* WOLFSSL_DEBUG_ON */
+#include <wolfssl/wolfcrypt/dh.h>
+#include <wolfssl/wolfcrypt/error-crypt.h>
+#include <wolfssl/openssl/ec.h>
+#endif /* defined(WITH_WOLFSSL) */
+
 /**************************************** OpenSSL headers */
 
 #define OPENSSL_THREAD_DEFINES
@@ -455,13 +476,62 @@ extern char *sys_errlist[];
 #endif /* !defined(OPENSSL_NO_SSL2) */
 #else /* OpenSSL older than 1.1.0 */
 #define X509_STORE_CTX_get0_chain(x) X509_STORE_CTX_get_chain(x)
+#ifndef WITH_WOLFSSL
 #define OPENSSL_hexstr2buf string_to_hex
+#endif
 #endif /* OpenSSL 1.1.0 or newer */
 
 #if OPENSSL_VERSION_NUMBER<0x10101000L
 #define OPENSSL_NO_TLS1_3
 #endif /* OpenSSL older than 1.1.1 */
 
+/* WOLFSSL_SPECIFIC ifdefs */
+#ifdef WITH_WOLFSSL
+
+#if defined(WOLFSSL_TLS13) && defined(OPENSSL_NO_TLS1_3)
+#undef OPENSSL_NO_TLS1_3
+#endif
+
+#ifndef WOLFSSL_ALLOW_SSLV3
+#ifndef OPENSSL_NO_SSL3
+#define OPENSSL_NO_SSL3
+#endif /* !defined(OPENSSL_NO_SSL3) */
+#endif /*WOLFSSL_ALLOW_SSLv3 */
+
+#ifndef OPENSSL_NO_ENGINE
+#define OPENSSL_NO_ENGINE
+#endif /* OPENSSL_NO_ENGINE */
+
+#ifndef OPENSSL_NO_COMP
+#define OPENSSL_NO_COMP
+#endif /* OPENSSL_NO_COMP */
+
+#ifndef OPENSSL_NO_SSL2
+#define OPENSSL_NO_SSL2
+#endif /* !defined(OPENSSL_NO_SSL2) */
+
+#ifndef CRYPTO_w_lock
+#define CRYPTO_w_lock CRYPTO_THREAD_lock
+#endif /* CRYPTO_w_lock */
+
+#ifndef CRYPTO_w_unlock
+#define CRYPTO_w_unlock CRYPTO_THREAD_unlock
+#endif /* CRYPTO_w_lock */
+
+#if defined(NO_OLD_TLS) || !defined(WOLFSSL_ALLOW_TLSV10)
+#define OPENSSL_NO_TLS1
+#endif
+
+#ifdef NO_OLD_TLS
+#define OPENSSL_NO_TLS1_1
+#endif
+
+#ifdef WOLFSSL_NO_TLS12
+#define OPENSSL_NO_TLS1_2
+#endif
+
+#endif /* defined (WITH_WOLFSSL) */
+
 #if defined(USE_WIN32) && defined(OPENSSL_FIPS)
 #define USE_FIPS
 #endif
diff --git a/src/cron.c b/src/cron.c
index e75642d..b72ca67 100644
--- a/src/cron.c
+++ b/src/cron.c
@@ -53,7 +53,7 @@ NOEXPORT unsigned __stdcall cron_thread(void *arg);
 #ifdef USE_OS_THREADS
 NOEXPORT void cron_worker(void);
 #ifndef OPENSSL_NO_DH
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
 NOEXPORT void cron_dh_param(BN_GENCB *);
 NOEXPORT BN_GENCB *cron_bn_gencb(void);
 NOEXPORT int bn_callback(int, int, BN_GENCB *);
@@ -142,19 +142,19 @@ int cron_init() {
 NOEXPORT void cron_worker(void) {
     time_t now, then;
     int delay;
-#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
     BN_GENCB *bn_gencb;
 #endif
 
     s_log(LOG_DEBUG, "Cron thread initialized");
-#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
     bn_gencb=cron_bn_gencb();
 #endif
     time(&then);
     for(;;) {
         s_log(LOG_INFO, "Executing cron jobs");
 #ifndef OPENSSL_NO_DH
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
         cron_dh_param(bn_gencb);
 #else /* OpenSSL older than 0.9.8 */
         cron_dh_param();
@@ -183,7 +183,7 @@ NOEXPORT void cron_worker(void) {
 
 #ifndef OPENSSL_NO_DH
 
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
 NOEXPORT void cron_dh_param(BN_GENCB *bn_gencb) {
 #else /* OpenSSL older than 0.9.8 */
 NOEXPORT void cron_dh_param(void) {
@@ -195,7 +195,7 @@ NOEXPORT void cron_dh_param(void) {
         return;
 
     s_log(LOG_NOTICE, "Updating DH parameters");
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
     /* generate 2048-bit DH parameters */
     dh=DH_new();
     if(!dh) {
@@ -230,7 +230,7 @@ NOEXPORT void cron_dh_param(void) {
     s_log(LOG_NOTICE, "DH parameters updated");
 }
 
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
 
 NOEXPORT BN_GENCB *cron_bn_gencb(void) {
 #if OPENSSL_VERSION_NUMBER>=0x10100000L
diff --git a/src/ctx.c b/src/ctx.c
index 63b1719..dafa587 100644
--- a/src/ctx.c
+++ b/src/ctx.c
@@ -60,7 +60,9 @@ NOEXPORT int matches_wildcard(const char *, const char *);
 /* DH/ECDH */
 #ifndef OPENSSL_NO_DH
 NOEXPORT int dh_init(SERVICE_OPTIONS *);
+#ifndef WITH_WOLFSSL
 NOEXPORT DH *dh_read(char *);
+#endif /* WITH_WOLFSSL  */
 #endif /* OPENSSL_NO_DH */
 #ifndef OPENSSL_NO_ECDH
 NOEXPORT int ecdh_init(SERVICE_OPTIONS *);
@@ -193,7 +195,7 @@ int context_init(SERVICE_OPTIONS *section) { /* init TLS context */
 
     /* ciphers */
     if(section->cipher_list) {
-        s_log(LOG_DEBUG, "Ciphers: %s", section->cipher_list);
+        s_log(LOG_INFO, "Ciphers: %s", section->cipher_list);
         if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {
             sslerror("SSL_CTX_set_cipher_list");
             return 1; /* FAILED */
@@ -382,13 +384,22 @@ NOEXPORT int matches_wildcard(const char *servername, const char *pattern) {
 
 #ifndef OPENSSL_NO_DH
 
-#if OPENSSL_VERSION_NUMBER<0x10100000L
+#if(OPENSSL_VERSION_NUMBER<0x10100000L) && !defined(WITH_WOLFSSL)
 NOEXPORT STACK_OF(SSL_CIPHER) *SSL_CTX_get_ciphers(const SSL_CTX *ctx) {
     return ctx->cipher_list;
 }
 #endif
 
 NOEXPORT int dh_init(SERVICE_OPTIONS *section) {
+#ifdef WITH_WOLFSSL
+    s_log(LOG_DEBUG, "DH initialization");
+    if(wolfSSL_CTX_SetTmpDH_file(section->ctx, section->cert,
+               SSL_FILETYPE_ASN1) == SSL_SUCCESS) { /* DH file loading failed */
+        return 0;
+     } else {
+        s_log(LOG_DEBUG, "Error loading DH params from file: %s", section->cert);
+    }
+#else
     DH *dh=NULL;
     int i, n;
     char description[128];
@@ -432,6 +443,8 @@ NOEXPORT int dh_init(SERVICE_OPTIONS *section) {
         DH_free(dh);
         return 0; /* OK */
     }
+#endif /* WITH_WOLFSSL */
+
     CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_DH]);
     SSL_CTX_set_tmp_dh(section->ctx, dh_params);
     CRYPTO_THREAD_unlock(stunnel_locks[LOCK_DH]);
@@ -441,6 +454,7 @@ NOEXPORT int dh_init(SERVICE_OPTIONS *section) {
     return 0; /* OK */
 }
 
+#ifndef WITH_WOLFSSL
 NOEXPORT DH *dh_read(char *cert) {
     DH *dh;
     BIO *bio;
@@ -465,6 +479,7 @@ NOEXPORT DH *dh_read(char *cert) {
     s_log(LOG_DEBUG, "Using DH parameters from %s", cert);
     return dh;
 }
+#endif /* WITH_WOLFSSL */
 
 #endif /* OPENSSL_NO_DH */
 
@@ -472,7 +487,7 @@ NOEXPORT DH *dh_read(char *cert) {
 
 #ifndef OPENSSL_NO_ECDH
 
-#if OPENSSL_VERSION_NUMBER < 0x10101000L
+#if OPENSSL_VERSION_NUMBER < 0x10101000L && !defined(WITH_WOLFSSL)
 /* simplified version that only supports a single curve */
 NOEXPORT int SSL_CTX_set1_groups_list(SSL_CTX *ctx, char *list) {
     int nid;
@@ -496,9 +511,15 @@ NOEXPORT int SSL_CTX_set1_groups_list(SSL_CTX *ctx, char *list) {
     EC_KEY_free(ecdh);
     return 1; /* OK */
 }
-#endif /* OpenSSL version < 1.1.1 */
+#endif /* OPENSSL_VERSION_NUMBER < 0x10101000L && !defined(WITH_WOLFSSL)  */
 
 NOEXPORT int ecdh_init(SERVICE_OPTIONS *section) {
+#ifdef WITH_WOLFSSL
+    /* wolfSSL automatically detects ecdh parameters from ECC key file.
+     * No need to load explicitly */
+    (void)section;
+    return 0;
+#else
     s_log(LOG_DEBUG, "ECDH initialization");
     if(!SSL_CTX_set1_groups_list(section->ctx, section->curves)) {
 #if OPENSSL_VERSION_NUMBER >= 0x10101000L
@@ -508,6 +529,7 @@ NOEXPORT int ecdh_init(SERVICE_OPTIONS *section) {
     }
     s_log(LOG_DEBUG, "ECDH initialized with curves %s", section->curves);
     return 0; /* OK */
+#endif /* WITH_WOLFSSL */
 }
 
 #endif /* OPENSSL_NO_ECDH */
@@ -742,6 +764,11 @@ NOEXPORT int pkcs12_extension(const char *filename) {
 }
 
 NOEXPORT int load_pkcs12_file(SERVICE_OPTIONS *section) {
+#ifdef WITH_WOLFSSL
+/* Currently no support for PKCS12 */
+    (void)section;
+    return 1;
+#else /* WITH_WOLFSSL */
     size_t len;
     int i, success;
     BIO *bio=NULL;
@@ -813,6 +840,7 @@ NOEXPORT int load_pkcs12_file(SERVICE_OPTIONS *section) {
     s_log(LOG_INFO, "Certificate and private key loaded from file: %s",
         section->cert);
     return 0; /* OK */
+#endif /* WITH_WOLFSSL */
 }
 
 NOEXPORT int load_cert_file(SERVICE_OPTIONS *section) {
@@ -952,6 +980,10 @@ NOEXPORT void set_prompt(const char *name) {
 }
 
 NOEXPORT int ui_retry() {
+#ifdef WITH_WOLFSSL
+    /* WOLFSSL does not support ERR_peek_error */
+    return 0;
+#else
     unsigned long err=ERR_peek_error();
 
     switch(ERR_GET_LIB(err)) {
@@ -997,6 +1029,7 @@ NOEXPORT int ui_retry() {
     default:
         return 0;
     }
+#endif /* WITH_WOLFSSL */
 }
 
 /**************************************** session tickets */
@@ -1041,7 +1074,9 @@ NOEXPORT int generate_session_ticket_cb(SSL *ssl, void *arg) {
 
     retval=SSL_SESSION_set1_ticket_appdata(sess,
         &ticket_data, sizeof(TICKET_DATA));
+#ifndef WITH_WOLFSSL
     SSL_SESSION_free(sess);
+#endif
     return retval;
 }
 
@@ -1211,6 +1246,46 @@ void print_session_id(SSL_SESSION *sess) {
 }
 
 NOEXPORT void new_chain(CLI *c) {
+#ifdef WITH_WOLFSSL
+    char* chain;
+    WOLFSSL_X509_CHAIN* certChain;
+    int i, certSz, idx, size;
+
+    if(c->opt->chain) /* already cached */
+        return; /* this race condition is safe to ignore */
+
+    certChain = wolfSSL_get_peer_chain(c->ssl);
+    if(!certChain) {
+        s_log(LOG_INFO, "No peer certificate received");
+        return;
+    }
+
+    for(size=0, i=0; i < wolfSSL_get_chain_count(certChain); ++i) {
+        if(wolfSSL_get_chain_cert_pem(certChain, i, NULL, 0, &certSz)
+                != LENGTH_ONLY_E) {
+            s_log(LOG_ERR, "Unable to cache peer cert");
+            return;
+        }
+        size+=certSz;
+    }
+
+    chain=str_alloc_detached((size_t)size+1); /* +1 for '\0' */
+
+    idx = 0;
+    for(i=0; i <wolfSSL_get_chain_count(certChain); ++i) {
+        if(wolfSSL_get_chain_cert_pem(certChain, i, (unsigned char*)chain+idx,
+                   size-idx, &certSz) != SSL_SUCCESS){
+            s_log(LOG_ERR, "Unable to cache peer cert");
+            str_free(chain);
+            return;
+        }
+        idx+=certSz;
+    }
+    chain[size]='\0';
+    c->opt->chain=chain; /* this race condition is safe to ignore */
+    ui_new_chain(c->opt->section_number);
+    s_log(LOG_DEBUG, "Peer certificate was cached (%d bytes)", size);
+#else
     BIO *bio;
     int i, len;
     X509 *peer_cert;
@@ -1254,6 +1329,7 @@ NOEXPORT void new_chain(CLI *c) {
     c->opt->chain=chain; /* this race condition is safe to ignore */
     ui_new_chain(c->opt->section_number);
     s_log(LOG_DEBUG, "Peer certificate was cached (%d bytes)", len);
+#endif /* ifdef WITH_WOLFSSL */
 }
 
 /* cache client sessions */
@@ -1281,8 +1357,12 @@ NOEXPORT void session_cache_save(CLI *c, SSL_SESSION *sess) {
     }
     CRYPTO_THREAD_unlock(stunnel_locks[LOCK_SESSION]);
 
+#ifndef WITH_WOLFSSL
     if(old)
         SSL_SESSION_free(old);
+#else
+    (void)old;
+#endif
 }
 
 NOEXPORT SSL_SESSION *sess_get_cb(SSL *ssl,
@@ -1504,6 +1584,7 @@ NOEXPORT void info_callback(const SSL *ssl, int where, int ret) {
         s_log(LOG_DEBUG, "state = %x", state);
 #endif
 
+#ifndef WITH_WOLFSSL /* wolfSSL doesn't support get_state */
         /* log the client certificate request (if received) */
 #ifndef SSL3_ST_CR_CERT_REQ_A
         if(state==TLS_ST_CR_CERT_REQ)
@@ -1518,6 +1599,7 @@ NOEXPORT void info_callback(const SSL *ssl, int where, int ret) {
 #endif
             if(!SSL_get_client_CA_list((SSL *)ssl))
                 s_log(LOG_INFO, "Client certificate not requested");
+#endif /* WITH_WOLFSSL */
 
         /* prevent renegotiation DoS attack */
         if((where&SSL_CB_HANDSHAKE_DONE)
diff --git a/src/log.c b/src/log.c
index c7f786a..2e9a106 100644
--- a/src/log.c
+++ b/src/log.c
@@ -246,6 +246,13 @@ void log_flush(LOG_MODE new_mode) {
     CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);
 }
 
+#ifdef WOLFSSL_DEBUG_ON
+void wolfSSL_s_log(int level, const char *format)
+{
+    s_log(level+3,  "%s", format);
+}
+#endif
+
 NOEXPORT void log_raw(SERVICE_OPTIONS *opt,
         int level, char *stamp, char *id, char *text) {
     char *line;
diff --git a/src/mingw_wolfssl.mk b/src/mingw_wolfssl.mk
new file mode 100644
index 0000000..7637107
--- /dev/null
+++ b/src/mingw_wolfssl.mk
@@ -0,0 +1,70 @@
+## mingw/mingw64 Makefile
+# by Michal Trojnara 1998-2020
+
+# 32-bit Windows
+#win32_arch=win32
+#win32_targetcpu=i686
+#win32_mingw=mingw
+
+# 64-bit Windows
+#win32_arch=win64
+#win32_targetcpu=x86_64
+#win32_mingw=mingw64
+
+bindir = ../bin/$(win32_arch)
+objdir = ../obj/$(win32_arch)
+
+win32_ssl_dir = /opt/wolfssl_dll
+win32_cppflags = -I$(win32_ssl_dir)/include -I$(win32_ssl_dir)/include/wolfssl
+win32_cflags = -g -mthreads -O2
+#win32_cflags += -fstack-protector
+win32_cflags += -Wall -Wextra -Wpedantic -Wformat=2 -Wconversion -Wno-long-long
+win32_cflags += -D_FORTIFY_SOURCE=2 -DUNICODE -D_UNICODE -DWITH_WOLFSSL
+win32_ldflags = -g -mthreads
+#win32_ldflags += -fstack-protector
+# -fstack-protector is broken (at least in x86_64-w64-mingw32-gcc 8.2.0)
+
+# compiling with -D_FORTIFY_SOURCE=2 may require linking with -lssp
+win32_common_libs = -lws2_32 -lkernel32 -lssp
+win32_ssl_libs = -L$(win32_ssl_dir)/lib -lwolfssl
+win32_gui_libs = $(win32_common_libs) -lgdi32 -lpsapi $(win32_ssl_libs)
+win32_cli_libs = $(win32_common_libs) $(win32_ssl_libs)
+
+common_headers = common.h prototypes.h version.h
+win32_common = tls str file client log options protocol network resolver
+win32_common += ssl ctx verify sthreads fd dhparam cron stunnel
+win32_gui = ui_win_gui resources
+win32_cli = ui_win_cli
+win32_common_objs = $(addsuffix .o, $(addprefix $(objdir)/, $(win32_common)))
+win32_gui_objs = $(addsuffix .o, $(addprefix $(objdir)/, $(win32_gui)))
+win32_cli_objs = $(addsuffix .o, $(addprefix $(objdir)/, $(win32_cli)))
+
+win32_prefix = $(win32_targetcpu)-w64-mingw32-
+win32_cc = $(win32_prefix)gcc
+win32_windres = $(win32_prefix)windres
+
+all: mkdirs $(bindir)/stunnel.exe $(bindir)/tstunnel.exe
+
+mkdirs:
+	mkdir -p $(bindir) $(objdir)
+
+$(bindir)/stunnel.exe: $(win32_common_objs) $(win32_gui_objs)
+	$(win32_cc) -mwindows $(win32_ldflags) -o $(bindir)/stunnel.exe $(win32_common_objs) $(win32_gui_objs) $(win32_gui_libs)
+#	-$(srcdir)/../sign/sign.sh $(bindir)/stunnel.exe
+
+$(bindir)/tstunnel.exe: $(win32_common_objs) $(win32_cli_objs)
+	$(win32_cc) $(win32_ldflags) -o $(bindir)/tstunnel.exe $(win32_common_objs) $(win32_cli_objs) $(win32_cli_libs)
+# 	-$(srcdir)/../sign/sign.sh $(bindir)/tstunnel.exe
+	
+
+$(objdir)/%.o: $(srcdir)/%.c
+	$(win32_cc) -c $(win32_cppflags) $(win32_cflags) -o $@ $<
+
+$(objdir)/%.o: $(common_headers)
+
+$(win32_gui_objs): $(srcdir)/resources.h
+
+$(objdir)/resources.o: $(srcdir)/resources.rc
+	$(win32_windres) --include-dir $(srcdir) $< $@
+
+$(objdir)/resources.o: $(srcdir)/version.h
diff --git a/src/options.c b/src/options.c
index 25c8f7b..87a9f26 100644
--- a/src/options.c
+++ b/src/options.c
@@ -276,12 +276,23 @@ static SERVICE_OPTIONS new_service_options;
 static char *option_not_found=
     "Specified option name is not valid here";
 
+#ifdef WITH_WOLFSSL
+/* Since wolfSSL doesn't support the same naming for cipher strings, we
+ * default to NULL and require the user to specify exact cipher_strings
+ * if they want to limit the cipher list */
+static char *stunnel_cipher_list=NULL;
+#else
 static char *stunnel_cipher_list=
-    "HIGH:!aNULL:!SSLv2:!DH:!kDHEPSK";
+    "HIGH:!DH:!aNULL:!SSLv2";
+#endif /* WITH_WOLFSSL */
 
 #ifndef OPENSSL_NO_TLS1_3
+#ifdef WITH_WOLFSSL
+static char *stunnel_ciphersuites=NULL;
+#else
 static char *stunnel_ciphersuites=
     "TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256";
+#endif
 #endif /* TLS 1.3 */
 
 /**************************************** parse commandline parameters */
@@ -1461,7 +1472,7 @@ NOEXPORT char *parse_service_option(CMD cmd, SERVICE_OPTIONS **section_ptr,
         break;
     }
 
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
 
     /* checkEmail */
     switch(cmd) {
@@ -1622,7 +1633,11 @@ NOEXPORT char *parse_service_option(CMD cmd, SERVICE_OPTIONS **section_ptr,
         }
         break;
     case CMD_PRINT_DEFAULTS:
+    #ifdef WITH_WOLFSSL
+        s_log(LOG_NOTICE, "wolfSSL will choose the most secure cipher supported by both client and server");
+    #else
         s_log(LOG_NOTICE, "%-22s = %s %s", "ciphersuites", stunnel_ciphersuites, "(with TLSv1.3)");
+    #endif
         break;
     case CMD_PRINT_HELP:
         s_log(LOG_NOTICE, "%-22s = permitted ciphersuites for TLS 1.3", "ciphersuites");
@@ -3685,7 +3700,9 @@ NOEXPORT char *parse_service_option(CMD cmd, SERVICE_OPTIONS **section_ptr,
     case CMD_FREE:
         str_free(section->chain);
         if(section->session)
+        #ifndef WITH_WOLFSSL
             SSL_SESSION_free(section->session);
+        #endif
         if(section->ctx)
             SSL_CTX_free(section->ctx);
         str_free(section->servname);
diff --git a/src/prototypes.h b/src/prototypes.h
index 50428f3..a7b5230 100644
--- a/src/prototypes.h
+++ b/src/prototypes.h
@@ -227,7 +227,7 @@ typedef struct service_options_struct {
     char *ocsp_url;
     unsigned long ocsp_flags;
 #endif /* !defined(OPENSSL_NO_OCSP) */
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
     NAME_LIST *check_host, *check_email, *check_ip;   /* cert subject checks */
     NAME_LIST *config;                               /* OpenSSL CONF options */
 #endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
@@ -518,6 +518,11 @@ void s_log(int, const char *, ...)
 #else
     ;
 #endif
+
+#ifdef WOLFSSL_DEBUG_ON
+void wolfSSL_s_log(int , const char *);
+#endif
+
 char *log_id(CLI *);
 void fatal_debug(char *, const char *, int) NORETURN;
 #define fatal(a) fatal_debug((a), __FILE__, __LINE__)
@@ -707,7 +712,9 @@ int getnameinfo(const struct sockaddr *, socklen_t,
 extern CLI *thread_head;
 #endif
 
-#if OPENSSL_VERSION_NUMBER<0x10100004L
+#ifdef WITH_WOLFSSL
+typedef wolfSSL_Mutex CRYPTO_RWLOCK;
+#elif OPENSSL_VERSION_NUMBER<0x10100004L
 
 #ifdef USE_OS_THREADS
 
@@ -757,12 +764,14 @@ typedef enum {
 extern CRYPTO_RWLOCK *stunnel_locks[STUNNEL_LOCKS];
 
 #if OPENSSL_VERSION_NUMBER<0x10100004L
+#ifndef WITH_WOLFSSL
 /* Emulate the OpenSSL 1.1 locking API for older OpenSSL versions */
 CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
 int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *);
 int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *);
 int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *);
 void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *);
+#endif /* WITH_WOLFSSL */
 int CRYPTO_atomic_add(int *, int, int *, CRYPTO_RWLOCK *);
 #endif
 
diff --git a/src/ssl.c b/src/ssl.c
index b2b63c8..7203249 100644
--- a/src/ssl.c
+++ b/src/ssl.c
@@ -69,8 +69,8 @@ int ssl_init(void) { /* init TLS before parsing configuration file */
         OPENSSL_INIT_LOAD_CRYPTO_STRINGS | OPENSSL_INIT_LOAD_CONFIG, NULL);
 #else
     OPENSSL_config(NULL);
-    SSL_load_error_strings();
     SSL_library_init();
+    SSL_load_error_strings();
 #endif
     index_ssl_cli=SSL_get_ex_new_index(0,
         "CLI pointer", NULL, NULL, NULL);
@@ -96,6 +96,7 @@ int ssl_init(void) { /* init TLS before parsing configuration file */
         return 1;
     }
 #endif /* OPENSSL_NO_DH */
+
     return 0;
 }
 
@@ -279,6 +280,7 @@ NOEXPORT int compression_init(GLOBAL_OPTIONS *global) {
 NOEXPORT int prng_init(GLOBAL_OPTIONS *global) {
     int totbytes=0;
     char filename[256];
+#ifndef WITH_WOLFSSL
     const RAND_METHOD *meth=RAND_get_rand_method();
 
     /* skip PRNG initialization when no seeding methods are available */
@@ -286,6 +288,7 @@ NOEXPORT int prng_init(GLOBAL_OPTIONS *global) {
         s_log(LOG_DEBUG, "No PRNG seeding methods");
         return 0; /* success */
     }
+#endif
 
     if(RAND_status()) {
         s_log(LOG_DEBUG, "No PRNG seeding was required");
diff --git a/src/sthreads.c b/src/sthreads.c
index d4c8214..81e193d 100644
--- a/src/sthreads.c
+++ b/src/sthreads.c
@@ -122,6 +122,8 @@ void thread_id_init(void) {
 /* we only need to initialize locking with OpenSSL older than 1.1.0 */
 #if OPENSSL_VERSION_NUMBER<0x10100004L
 
+#ifndef WITH_WOLFSSL
+
 #ifdef USE_PTHREAD
 
 NOEXPORT void s_lock_init_debug(struct CRYPTO_dynlock_value *lock,
@@ -206,6 +208,8 @@ NOEXPORT void s_lock_destroy_debug(struct CRYPTO_dynlock_value *lock,
 
 #endif /* USE_WIN32 */
 
+#endif /* WITH_WOLFSSL */
+
 NOEXPORT int s_atomic_add(int *val, int amount, CRYPTO_RWLOCK *lock) {
     int ret;
 
@@ -231,6 +235,8 @@ CRYPTO_RWLOCK *stunnel_locks[STUNNEL_LOCKS];
 
 #if OPENSSL_VERSION_NUMBER<0x10100004L
 
+#ifndef WITH_WOLFSSL
+
 #ifdef USE_OS_THREADS
 
 static struct CRYPTO_dynlock_value *lock_cs;
@@ -330,6 +336,8 @@ void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock) {
 
 #endif /* USE_OS_THREADS */
 
+#endif /* WITH_WOLFSSL */
+
 int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock) {
     *ret=s_atomic_add(val, amount, lock);
     return 1;
@@ -339,7 +347,7 @@ int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock) {
 
 void locking_init(void) {
     size_t i;
-#if defined(USE_OS_THREADS) && OPENSSL_VERSION_NUMBER<0x10100004L
+#if defined(USE_OS_THREADS) && OPENSSL_VERSION_NUMBER<0x10100004L && !defined(WITH_WOLFSSL)
     size_t num;
 
     /* initialize the OpenSSL static locking */
diff --git a/src/stunnel.c b/src/stunnel.c
index 4f45930..20a1ed1 100644
--- a/src/stunnel.c
+++ b/src/stunnel.c
@@ -48,7 +48,9 @@
 #pragma GCC diagnostic ignored "-Wpedantic"
 #endif /* __GNUC__ */
 
+#ifndef WITH_WOLFSSL
 #include <openssl/applink.c>
+#endif
 
 #ifdef __GNUC__
 #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
@@ -120,10 +122,16 @@ void main_init() { /* one-time initialization */
 #endif
     /* basic initialization contains essential functions required for logging
      * subsystem to function properly, thus all errors here are fatal */
+#ifndef WITH_WOLFSSL
     if(ssl_init()) /* initialize TLS library */
         fatal("TLS initialization failed");
+#endif
     if(sthreads_init()) /* initialize critical sections & TLS callbacks */
         fatal("Threads initialization failed");
+#ifdef WITH_WOLFSSL
+    if(ssl_init()) /* initialize TLS library */
+        fatal("TLS initialization failed");
+#endif
     options_defaults(); /* initialize defaults */
     options_apply(); /* apply the defaults */
 #ifndef USE_FORK
diff --git a/src/ui_unix.c b/src/ui_unix.c
index 5092124..c391d60 100644
--- a/src/ui_unix.c
+++ b/src/ui_unix.c
@@ -71,6 +71,10 @@ NOEXPORT int main_unix(int argc, char* argv[]) {
         fatal("Could not open /dev/null");
 #endif
     main_init();
+#ifdef WOLFSSL_DEBUG_ON
+    wolfSSL_Debugging_ON();
+    wolfSSL_SetLoggingCb((wolfSSL_Logging_cb)&wolfSSL_s_log);
+#endif
     configure_status=main_configure(argc>1 ? argv[1] : NULL,
         argc>2 ? argv[2] : NULL);
     switch(configure_status) {
diff --git a/src/ui_win_cli.c b/src/ui_win_cli.c
index 7678137..9512295 100644
--- a/src/ui_win_cli.c
+++ b/src/ui_win_cli.c
@@ -70,6 +70,10 @@ int main(int argc, char *argv[]) {
         return 1;
     resolver_init();
     main_init();
+#ifdef WOLFSSL_DEBUG_ON
+    wolfSSL_Debugging_ON();
+    wolfSSL_SetLoggingCb((wolfSSL_Logging_cb)&wolfSSL_s_log);
+#endif
     if(!main_configure(argc>1 ? argv[1] : NULL, argc>2 ? argv[2] : NULL))
         daemon_loop();
     main_cleanup();
diff --git a/src/ui_win_gui.c b/src/ui_win_gui.c
index a93e1aa..f8503df 100644
--- a/src/ui_win_gui.c
+++ b/src/ui_win_gui.c
@@ -72,7 +72,10 @@ NOEXPORT LRESULT CALLBACK window_proc(HWND, UINT, WPARAM, LPARAM);
 NOEXPORT void save_peer_certificate(WPARAM wParam);
 NOEXPORT LRESULT CALLBACK about_proc(HWND, UINT, WPARAM, LPARAM);
 NOEXPORT LRESULT CALLBACK pass_proc(HWND, UINT, WPARAM, LPARAM);
+
+#ifndef WITH_WOLFSSL
 NOEXPORT int pin_cb(UI *, UI_STRING *);
+#endif
 
 NOEXPORT void save_log(void);
 NOEXPORT void win_log(LPCTSTR);
@@ -766,7 +769,7 @@ int ui_passwd_cb(char *buf, int size, int rwflag, void *userdata) {
     return len;
 }
 
-#ifndef OPENSSL_NO_ENGINE
+#if !defined(OPENSSL_NO_ENGINE) && !defined(WITH_WOLFSSL)
 UI_METHOD *UI_stunnel() {
     static UI_METHOD *ui_method=NULL;
 
diff --git a/src/verify.c b/src/verify.c
index ee49d8b..7d96cd5 100644
--- a/src/verify.c
+++ b/src/verify.c
@@ -43,30 +43,34 @@
 /* verify initialization */
 NOEXPORT void set_client_CA_list(SERVICE_OPTIONS *section);
 NOEXPORT void auth_warnings(SERVICE_OPTIONS *);
+#ifndef WITH_WOLFSSL
 NOEXPORT int crl_init(SERVICE_OPTIONS *section);
 NOEXPORT int load_file_lookup(X509_STORE *, char *);
 NOEXPORT int add_dir_lookup(X509_STORE *, char *);
+#endif /*WITH_WOLFSSL*/
 
 /* verify callback */
 NOEXPORT int verify_callback(int, X509_STORE_CTX *);
 NOEXPORT int verify_checks(CLI *, int, X509_STORE_CTX *);
 NOEXPORT int cert_check(CLI *, X509_STORE_CTX *, int);
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
 NOEXPORT int cert_check_subject(CLI *, X509_STORE_CTX *);
 #endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
 NOEXPORT int cert_check_local(X509_STORE_CTX *);
 NOEXPORT int compare_pubkeys(X509 *, X509 *);
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
 NOEXPORT int ocsp_check(CLI *, X509_STORE_CTX *);
 NOEXPORT int ocsp_request(CLI *, X509_STORE_CTX *, OCSP_CERTID *, char *);
 NOEXPORT OCSP_RESPONSE *ocsp_get_response(CLI *, OCSP_REQUEST *, char *);
-#endif
+#endif /*!defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL) */
 
 /* utility functions */
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
 NOEXPORT X509 *get_current_issuer(X509_STORE_CTX *);
-NOEXPORT void log_time(const int, const char *, ASN1_TIME *);
 #endif
+#ifndef WITH_WOLFSSL
+NOEXPORT void log_time(const int, const char *, ASN1_TIME *);
+#endif /* !defined(WITH_WOLFSSL) */
 
 /**************************************** verify initialization */
 
@@ -86,8 +90,58 @@ int verify_init(SERVICE_OPTIONS *section) {
 
     /* CRL initialization */
     if(section->crl_file || section->crl_dir)
-        if(crl_init(section))
+#ifdef WITH_WOLFSSL
+    if(section->crl_dir) {
+        /* WOLFSSL handles CRL internally, no need to deal with lookups */
+        if(wolfSSL_CTX_EnableCRL(section->ctx, WOLFSSL_CRL_CHECKALL)
+                                                        != SSL_SUCCESS) {
+            sslerror("SSL_CTX_EnableCRL");
             return 1; /* FAILED */
+        } else if (wolfSSL_CTX_LoadCRL(section->ctx, section->crl_dir,
+                  SSL_FILETYPE_PEM, 0) != SSL_SUCCESS)
+        {
+            sslerror("SSL_CTX_LoadCRL");
+            return 1; /* FAILED */
+        }
+    }
+#else
+    if(crl_init(section))
+        return 1; /* FAILED */
+#endif /*WITH_WOLFSSL*/
+
+#ifdef WITH_WOLFSSL
+    if(section->ocsp_url)
+    {
+        if(wolfSSL_CTX_SetOCSP_OverrideURL(section->ctx, section->ocsp_url)
+                != SSL_SUCCESS) {
+            s_log(LOG_ERR, "Error setting OCSP Override URL to: %s)",
+                    section->ocsp_url);
+            sslerror("wolfSSL_CTX_SetOCSP_OverrideURL");
+            return 1; /* FAILED */
+        }
+        if(wolfSSL_CTX_EnableOCSP(section->ctx,
+                WOLFSSL_OCSP_URL_OVERRIDE) != SSL_SUCCESS) {
+            s_log(LOG_ERR, "Error enabling OCSP");
+            sslerror("wolfSSL_CTX_EnableOCSP");
+            return 1; /* FAILED */
+        }
+        s_log(LOG_DEBUG, "Enabled OCSP at URL: %s", section->ocsp_url);
+    }
+    if(section->option.aia==1)
+    {
+        if(section->ocsp_url) {
+            s_log(LOG_ERR, "Error: Cannot set ocsp lookup url with aia.");
+            s_log(LOG_ERR,"Please choose one. Error enabling OCSP");
+            sslerror("wolfSSL_CTX_EnableOCSP");
+        }
+        if(wolfSSL_CTX_EnableOCSP(section->ctx, 0) != SSL_SUCCESS) {
+            s_log(LOG_ERR, "Error enabling OCSP");
+            sslerror("wolfSSL_CTX_EnableOCSP");
+            return 1; /* FAILED */
+        }
+        s_log(LOG_INFO, "Enabled OCSP with aia extension.");
+    }
+#endif /* ifdef WITH_WOLFSSL */
 
     /* verify callback setup */
     if(section->option.request_cert) {
@@ -111,6 +165,7 @@ NOEXPORT void set_client_CA_list(SERVICE_OPTIONS *section) {
     print_client_CA_list(ca_dn);
 }
 
+#ifndef WITH_WOLFSSL
 NOEXPORT int crl_init(SERVICE_OPTIONS *section) {
     X509_STORE *store;
 
@@ -164,6 +219,7 @@ NOEXPORT int add_dir_lookup(X509_STORE *store, char *name) {
     s_log(LOG_DEBUG, "Added %s revocation lookup directory", name);
     return 0; /* OK */
 }
+#endif /*WITH_WOLFSSL*/
 
 /* issue warnings on insecure/missing authentication */
 NOEXPORT void auth_warnings(SERVICE_OPTIONS *section) {
@@ -201,7 +257,7 @@ NOEXPORT void auth_warnings(SERVICE_OPTIONS *section) {
 /**************************************** verify callback */
 
 NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {
-        /* our verify callback function */
+    /* our verify callback function */
     SSL *ssl;
     CLI *c;
 
@@ -223,7 +279,9 @@ NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {
         if(sess) {
             int ok=SSL_SESSION_set_ex_data(sess,
                 index_session_authenticated, NULL);
+        #ifndef WITH_WOLFSSL
             SSL_SESSION_free(sess);
+        #endif
             if(!ok) {
                 sslerror("SSL_SESSION_set_ex_data");
                 return 0; /* reject */
@@ -251,14 +309,14 @@ NOEXPORT int verify_checks(CLI *c,
         str_free(subject);
         return 0; /* reject */
     }
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
     if((c->opt->ocsp_url || c->opt->option.aia) &&
             !ocsp_check(c, callback_ctx)) {
         s_log(LOG_WARNING, "Rejected by OCSP at depth=%d: %s", depth, subject);
         str_free(subject);
         return 0; /* reject */
     }
-#endif /* !defined(OPENSSL_NO_OCSP) */
+#endif /* !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL) */
 
     s_log(depth ? LOG_INFO : LOG_NOTICE,
         "Certificate accepted at depth=%d: %s", depth, subject);
@@ -290,10 +348,10 @@ NOEXPORT int cert_check(CLI *c, X509_STORE_CTX *callback_ctx,
     }
 
     if(depth==0) { /* additional peer certificate checks */
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
         if(!cert_check_subject(c, callback_ctx))
             return 0; /* reject */
-#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
+#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL) */
         if(c->opt->option.verify_peer && !cert_check_local(callback_ctx))
             return 0; /* reject */
     }
@@ -301,7 +359,7 @@ NOEXPORT int cert_check(CLI *c, X509_STORE_CTX *callback_ctx,
     return 1; /* accept */
 }
 
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L  || defined(WITH_WOLFSSL)
 NOEXPORT int cert_check_subject(CLI *c, X509_STORE_CTX *callback_ctx) {
     X509 *cert=X509_STORE_CTX_get_current_cert(callback_ctx);
     NAME_LIST *ptr;
@@ -337,7 +395,7 @@ NOEXPORT int cert_check_subject(CLI *c, X509_STORE_CTX *callback_ctx) {
     s_log(LOG_WARNING, "CERT: Subject checks failed");
     return 0; /* reject */
 }
-#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
+#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL) */
 
 #if OPENSSL_VERSION_NUMBER>=0x10000000L
 /* modern implementation for OpenSSL version >= 1.0.0 */
@@ -351,7 +409,7 @@ NOEXPORT int cert_check_local(X509_STORE_CTX *callback_ctx) {
     cert=X509_STORE_CTX_get_current_cert(callback_ctx);
     subject=X509_get_subject_name(cert);
 
-#if OPENSSL_VERSION_NUMBER<0x10100006L
+#if OPENSSL_VERSION_NUMBER<0x10100006L || defined(WITH_WOLFSSL)
 #define X509_STORE_CTX_get1_certs X509_STORE_get1_certs
 #endif
     /* modern API allows retrieving multiple matching certificates */
@@ -403,6 +461,44 @@ NOEXPORT int cert_check_local(X509_STORE_CTX *callback_ctx) {
 #endif /* OPENSSL_VERSION_NUMBER>=0x10000000L */
 
 NOEXPORT int compare_pubkeys(X509 *c1, X509 *c2) {
+#ifdef WITH_WOLFSSL
+    int c1Sz;
+    unsigned char *c1Data;
+    int c2Sz;
+    unsigned char *c2Data;
+    int ret;
+
+    /* First, call wolfSSL_X509_get_pubkey_buffer with NULL buffer, to get 
+     * the required buffer size. */
+    ret = wolfSSL_X509_get_pubkey_buffer(c1, NULL, &c1Sz);
+    if (ret != WOLFSSL_SUCCESS) {
+        return 0; /* reject */
+    }
+    c1Data = (unsigned char*) malloc(c1Sz);
+    
+    ret = wolfSSL_X509_get_pubkey_buffer(c2, NULL, &c2Sz);
+    if (ret != WOLFSSL_SUCCESS) {
+        return 0; /* reject */
+    }
+    c2Data = (unsigned char*) malloc(c2Sz);
+
+    if (c1Data == NULL
+     || c2Data == NULL
+     || wolfSSL_X509_get_pubkey_buffer(c1, c1Data, &c1Sz) != WOLFSSL_SUCCESS
+     || wolfSSL_X509_get_pubkey_buffer(c2, c2Data, &c2Sz) != WOLFSSL_SUCCESS
+     || c1Sz != c2Sz || safe_memcmp(c1Data, c2Data, (size_t)c1Sz)) {
+        ret = 0; /* reject */
+    }
+    else {
+        ret = 1; /* accept */
+        s_log(LOG_INFO, "CERT: Locally installed certificate matched");
+    }
+
+    free(c1Data);
+    free(c2Data);
+
+    return ret;
+#else
     ASN1_BIT_STRING *k1=X509_get0_pubkey_bitstr(c1);
     ASN1_BIT_STRING *k2=X509_get0_pubkey_bitstr(c2);
     if(!k1 || !k2 || k1->length!=k2->length || k1->length<0 ||
@@ -410,11 +506,12 @@ NOEXPORT int compare_pubkeys(X509 *c1, X509 *c2) {
         return 0; /* reject */
     s_log(LOG_INFO, "CERT: Locally installed certificate matched");
     return 1; /* accept */
+#endif
 }
 
 /**************************************** OCSP checking */
 
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
 
 #ifdef DEFINE_STACK_OF
 /* defined in openssl/safestack.h:
@@ -735,7 +832,7 @@ NOEXPORT void log_time(const int level, const char *txt, ASN1_TIME *t) {
     str_free(cp);
 }
 
-#endif /* !defined(OPENSSL_NO_OCSP) */
+#endif /* !defined(OPENSSL_NO_OCSP)  && !defined(WITH_WOLFSSL) */
 
 void print_client_CA_list(const STACK_OF(X509_NAME) *ca_dn) {
     char *ca_name;
@@ -759,6 +856,15 @@ void print_client_CA_list(const STACK_OF(X509_NAME) *ca_dn) {
 
 char *X509_NAME2text(X509_NAME *name) {
     char *text;
+#ifdef WITH_WOLFSSL
+    int sz;
+    sz=wolfSSL_X509_NAME_get_sz(name);
+    if(sz<=0)
+        return str_dup("Invalid X509_NAME");
+    text=str_alloc((size_t)sz+1); /* one byte for '\0' excape */
+    text=wolfSSL_X509_NAME_oneline(name, text, sz);
+    text[sz]='\0';
+#else
     BIO *bio;
     int n;
 
@@ -777,6 +883,7 @@ char *X509_NAME2text(X509_NAME *name) {
     }
     text[n]='\0';
     BIO_free(bio);
+#endif /* WITH_WOLFSSL */
     return text;
 }
 
