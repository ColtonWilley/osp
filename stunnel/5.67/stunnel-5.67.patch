diff --git a/configure.ac b/configure.ac
index a4948f0..2720cdb 100644
--- a/configure.ac
+++ b/configure.ac
@@ -449,26 +449,65 @@ find_ssl_dir() { :
     check_ssl_dir "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib/swift-migrator/sdk/MacOSX.sdk/usr"
 }
 
-SSLDIR=""
-AC_MSG_CHECKING([for TLS directory])
-AC_ARG_WITH(ssl,
-[  --with-ssl=DIR          location of installed TLS libraries/include files],
-    [check_ssl_dir "$withval"],
-    [find_ssl_dir]
-)
-if test -z "$SSLDIR"; then
-AC_MSG_RESULT([not found])
-AC_MSG_ERROR([
-Could not find your TLS library installation dir
-Use --with-ssl option to fix this problem
-])
+AC_ARG_ENABLE([wolfssl],
+    [  --enable-wolfssl        Enable stunnel with wolfSSL (default: disabled)],
+    [ ENABLED_WOLFSSL=$enableval ],
+    [ ENABLED_WOLFSSL=$no ])
+
+if test "x$ENABLED_WOLFSSL" = "xyes"
+then
+    AM_CFLAGS="$AM_CFLAGS -DWITH_WOLFSSL"
+    if test -z "$SSLDIR"; then
+        SSLDIR="/usr/local"
+    fi
+    AC_DEFINE([WITH_WOLFSSL], [1],
+    [Define to 1 if you using WOLFSSL header file.])
+fi
+
+AM_CONDITIONAL([WOLFSSL], test "x$ENABLED_WOLFSSL" = "xyes")
+
+AC_ARG_ENABLE([wolfssldebug],
+    [  --enable-wolfssldebug   Enable wolfSSL debugging information (default: disabled)],
+    [ ENABLED_WOLFSSLDEBUG=$enableval ],
+    [ ENABLED_WOLFSSLDEBUG=$no ])
+if test "x$ENABLED_WOLFSSLDEBUG" = "xyes"
+then
+    AM_CFLAGS="$AM_CFLAGS -DWITH_WOLFSSL_DEBUG"
+    AC_DEFINE([WOLFSSL_DEBUG_ON], [1],
+    [Define to 1 to enable WOLFSSL debug messages.])
+fi
+
+AM_CONDITIONAL([WOLFSSL_DEBUG_ON], test "x$ENABLED_WOLFSSLDEBUG" = "xyes")
+
+if test "x$ENABLED_WOLFSSL" = "xno"
+then
+    SSLDIR=""
+    AC_MSG_CHECKING([for TLS directory])
+    AC_ARG_WITH(ssl,
+    [  --with-ssl=DIR          location of installed SSL libraries/include files],
+        [check_ssl_dir "$withval"],
+        [find_ssl_dir]
+    )
+    if test -z "$SSLDIR"; then
+    AC_MSG_RESULT([not found])
+    AC_MSG_ERROR([
+    Could not find your TLS library installation dir
+    Use --with-ssl option to fix this problem
+    ]) 
+    fi
 fi
 AC_MSG_RESULT([$SSLDIR])
 AC_SUBST([SSLDIR])
 AC_DEFINE_UNQUOTED([SSLDIR], ["$SSLDIR"], [TLS directory])
 
+if test "x$ENABLED_WOLFSSL" = "xyes"
+then
+valid_CPPFLAGS="$CPPFLAGS"; CPPFLAGS="$CPPFLAGS -I$SSLDIR/include -I$SSLDIR/include/wolfssl"
+valid_LIBS="$LIBS"; LIBS="$LIBS -L$SSLDIR/lib64 -L$SSLDIR/lib -lwolfssl"
+else
 valid_CPPFLAGS="$CPPFLAGS"; CPPFLAGS="$CPPFLAGS -I$SSLDIR/include"
 valid_LIBS="$LIBS"; LIBS="$LIBS -L$SSLDIR/lib64 -L$SSLDIR/lib -lssl -lcrypto"
+fi
 
 AC_CHECK_FUNCS(FIPS_mode_set OSSL_PROVIDER_available)
 if test "x$use_fips" = "xauto"; then
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
new file mode 100644
index 0000000..601011a
--- /dev/null
+++ b/m4/acinclude.m4
@@ -0,0 +1,775 @@
+# ============================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_append_compile_flags.html
+# ============================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_COMPILE_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   For every FLAG1, FLAG2 it is checked whether the compiler works with the
+#   flag.  If it does, the flag is added FLAGS-VARIABLE
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  During the check the flag is always added to the
+#   current language's flags.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: This macro depends on the AX_APPEND_FLAG and
+#   AX_CHECK_COMPILE_FLAG. Please keep this macro in sync with
+#   AX_APPEND_LINK_FLAGS.
+#
+# LICENSE
+#
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 7
+
+AC_DEFUN([AX_APPEND_COMPILE_FLAGS],
+[AX_REQUIRE_DEFINED([AX_CHECK_COMPILE_FLAG])
+AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
+for flag in $1; do
+  AX_CHECK_COMPILE_FLAG([$flag], [AX_APPEND_FLAG([$flag], [$2])], [], [$3], [$4])
+done
+])dnl AX_APPEND_COMPILE_FLAGS
+
+# ===========================================================================
+#      https://www.gnu.org/software/autoconf-archive/ax_append_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_FLAG(FLAG, [FLAGS-VARIABLE])
+#
+# DESCRIPTION
+#
+#   FLAG is appended to the FLAGS-VARIABLE shell variable, with a space
+#   added in between.
+#
+#   If FLAGS-VARIABLE is not specified, the current language's flags (e.g.
+#   CFLAGS) is used.  FLAGS-VARIABLE is not changed if it already contains
+#   FLAG.  If FLAGS-VARIABLE is unset in the shell, it is set to exactly
+#   FLAG.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 8
+
+AC_DEFUN([AX_APPEND_FLAG],
+[dnl
+AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_SET_IF
+AS_VAR_PUSHDEF([FLAGS], [m4_default($2,_AC_LANG_PREFIX[FLAGS])])
+AS_VAR_SET_IF(FLAGS,[
+  AS_CASE([" AS_VAR_GET(FLAGS) "],
+    [*" $1 "*], [AC_RUN_LOG([: FLAGS already contains $1])],
+    [
+     AS_VAR_APPEND(FLAGS,[" $1"])
+     AC_RUN_LOG([: FLAGS="$FLAGS"])
+    ])
+  ],
+  [
+  AS_VAR_SET(FLAGS,[$1])
+  AC_RUN_LOG([: FLAGS="$FLAGS"])
+  ])
+AS_VAR_POPDEF([FLAGS])dnl
+])dnl AX_APPEND_FLAG
+
+# ===========================================================================
+#   https://www.gnu.org/software/autoconf-archive/ax_append_link_flags.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_APPEND_LINK_FLAGS([FLAG1 FLAG2 ...], [FLAGS-VARIABLE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   For every FLAG1, FLAG2 it is checked whether the linker works with the
+#   flag.  If it does, the flag is added FLAGS-VARIABLE
+#
+#   If FLAGS-VARIABLE is not specified, the linker's flags (LDFLAGS) is
+#   used. During the check the flag is always added to the linker's flags.
+#
+#   If EXTRA-FLAGS is defined, it is added to the linker's default flags
+#   when the check is done.  The check is thus made with the flags: "LDFLAGS
+#   EXTRA-FLAGS FLAG".  This can for example be used to force the linker to
+#   issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: This macro depends on the AX_APPEND_FLAG and AX_CHECK_LINK_FLAG.
+#   Please keep this macro in sync with AX_APPEND_COMPILE_FLAGS.
+#
+# LICENSE
+#
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 7
+
+AC_DEFUN([AX_APPEND_LINK_FLAGS],
+[AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
+AX_REQUIRE_DEFINED([AX_APPEND_FLAG])
+for flag in $1; do
+  AX_CHECK_LINK_FLAG([$flag], [AX_APPEND_FLAG([$flag], [m4_default([$2], [LDFLAGS])])], [], [$3], [$4])
+done
+])dnl AX_APPEND_LINK_FLAGS
+
+# ===========================================================================
+#  https://www.gnu.org/software/autoconf-archive/ax_check_compile_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_COMPILE_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   Check whether the given FLAG works with the current language's compiler
+#   or gives an error.  (Warnings, however, are ignored)
+#
+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
+#   success/failure.
+#
+#   If EXTRA-FLAGS is defined, it is added to the current language's default
+#   flags (e.g. CFLAGS) when the check is done.  The check is thus made with
+#   the flags: "CFLAGS EXTRA-FLAGS FLAG".  This can for example be used to
+#   force the compiler to issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_COMPILE_IFELSE.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
+#   macro in sync with AX_CHECK_{PREPROC,LINK}_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 6
+
+AC_DEFUN([AX_CHECK_COMPILE_FLAG],
+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_[]_AC_LANG_ABBREV[]flags_$4_$1])dnl
+AC_CACHE_CHECK([whether _AC_LANG compiler accepts $1], CACHEVAR, [
+  ax_check_save_flags=$[]_AC_LANG_PREFIX[]FLAGS
+  _AC_LANG_PREFIX[]FLAGS="$[]_AC_LANG_PREFIX[]FLAGS $4 $1"
+  AC_COMPILE_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  _AC_LANG_PREFIX[]FLAGS=$ax_check_save_flags])
+AS_VAR_IF(CACHEVAR,yes,
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_COMPILE_FLAGS
+
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_check_link_flag.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_CHECK_LINK_FLAG(FLAG, [ACTION-SUCCESS], [ACTION-FAILURE], [EXTRA-FLAGS], [INPUT])
+#
+# DESCRIPTION
+#
+#   Check whether the given FLAG works with the linker or gives an error.
+#   (Warnings, however, are ignored)
+#
+#   ACTION-SUCCESS/ACTION-FAILURE are shell commands to execute on
+#   success/failure.
+#
+#   If EXTRA-FLAGS is defined, it is added to the linker's default flags
+#   when the check is done.  The check is thus made with the flags: "LDFLAGS
+#   EXTRA-FLAGS FLAG".  This can for example be used to force the linker to
+#   issue an error when a bad flag is given.
+#
+#   INPUT gives an alternative input source to AC_LINK_IFELSE.
+#
+#   NOTE: Implementation based on AX_CFLAGS_GCC_OPTION. Please keep this
+#   macro in sync with AX_CHECK_{PREPROC,COMPILE}_FLAG.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Guido U. Draheim <guidod@gmx.de>
+#   Copyright (c) 2011 Maarten Bosmans <mkbosmans@gmail.com>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved.  This file is offered as-is, without any
+#   warranty.
+
+#serial 6
+
+AC_DEFUN([AX_CHECK_LINK_FLAG],
+[AC_PREREQ(2.64)dnl for _AC_LANG_PREFIX and AS_VAR_IF
+AS_VAR_PUSHDEF([CACHEVAR],[ax_cv_check_ldflags_$4_$1])dnl
+AC_CACHE_CHECK([whether the linker accepts $1], CACHEVAR, [
+  ax_check_save_flags=$LDFLAGS
+  LDFLAGS="$LDFLAGS $4 $1"
+  AC_LINK_IFELSE([m4_default([$5],[AC_LANG_PROGRAM()])],
+    [AS_VAR_SET(CACHEVAR,[yes])],
+    [AS_VAR_SET(CACHEVAR,[no])])
+  LDFLAGS=$ax_check_save_flags])
+AS_VAR_IF(CACHEVAR,yes,
+  [m4_default([$2], :)],
+  [m4_default([$3], :)])
+AS_VAR_POPDEF([CACHEVAR])dnl
+])dnl AX_CHECK_LINK_FLAGS
+
+# ===========================================================================
+#        https://www.gnu.org/software/autoconf-archive/ax_pthread.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_PTHREAD([ACTION-IF-FOUND[, ACTION-IF-NOT-FOUND]])
+#
+# DESCRIPTION
+#
+#   This macro figures out how to build C programs using POSIX threads. It
+#   sets the PTHREAD_LIBS output variable to the threads library and linker
+#   flags, and the PTHREAD_CFLAGS output variable to any special C compiler
+#   flags that are needed. (The user can also force certain compiler
+#   flags/libs to be tested by setting these environment variables.)
+#
+#   Also sets PTHREAD_CC to any special C compiler that is needed for
+#   multi-threaded programs (defaults to the value of CC otherwise). (This
+#   is necessary on AIX to use the special cc_r compiler alias.)
+#
+#   NOTE: You are assumed to not only compile your program with these flags,
+#   but also to link with them as well. For example, you might link with
+#   $PTHREAD_CC $CFLAGS $PTHREAD_CFLAGS $LDFLAGS ... $PTHREAD_LIBS $LIBS
+#
+#   If you are only building threaded programs, you may wish to use these
+#   variables in your default LIBS, CFLAGS, and CC:
+#
+#     LIBS="$PTHREAD_LIBS $LIBS"
+#     CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+#     CC="$PTHREAD_CC"
+#
+#   In addition, if the PTHREAD_CREATE_JOINABLE thread-attribute constant
+#   has a nonstandard name, this macro defines PTHREAD_CREATE_JOINABLE to
+#   that name (e.g. PTHREAD_CREATE_UNDETACHED on AIX).
+#
+#   Also HAVE_PTHREAD_PRIO_INHERIT is defined if pthread is found and the
+#   PTHREAD_PRIO_INHERIT symbol is defined when compiling with
+#   PTHREAD_CFLAGS.
+#
+#   ACTION-IF-FOUND is a list of shell commands to run if a threads library
+#   is found, and ACTION-IF-NOT-FOUND is a list of commands to run it if it
+#   is not found. If ACTION-IF-FOUND is not specified, the default action
+#   will define HAVE_PTHREAD.
+#
+#   Please let the authors know if this macro fails on any platform, or if
+#   you have any other suggestions or comments. This macro was based on work
+#   by SGJ on autoconf scripts for FFTW (http://www.fftw.org/) (with help
+#   from M. Frigo), as well as ac_pthread and hb_pthread macros posted by
+#   Alejandro Forero Cuervo to the autoconf macro repository. We are also
+#   grateful for the helpful feedback of numerous users.
+#
+#   Updated for Autoconf 2.68 by Daniel Richard G.
+#
+# LICENSE
+#
+#   Copyright (c) 2008 Steven G. Johnson <stevenj@alum.mit.edu>
+#   Copyright (c) 2011 Daniel Richard G. <skunk@iSKUNK.ORG>
+#
+#   This program is free software: you can redistribute it and/or modify it
+#   under the terms of the GNU General Public License as published by the
+#   Free Software Foundation, either version 3 of the License, or (at your
+#   option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+#   Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License along
+#   with this program. If not, see <https://www.gnu.org/licenses/>.
+#
+#   As a special exception, the respective Autoconf Macro's copyright owner
+#   gives unlimited permission to copy, distribute and modify the configure
+#   scripts that are the output of Autoconf when processing the Macro. You
+#   need not follow the terms of the GNU General Public License when using
+#   or distributing such scripts, even though portions of the text of the
+#   Macro appear in them. The GNU General Public License (GPL) does govern
+#   all other use of the material that constitutes the Autoconf Macro.
+#
+#   This special exception to the GPL applies to versions of the Autoconf
+#   Macro released by the Autoconf Archive. When you make and distribute a
+#   modified version of the Autoconf Macro, you may extend this special
+#   exception to the GPL to apply to your modified version as well.
+
+#serial 24
+
+AU_ALIAS([ACX_PTHREAD], [AX_PTHREAD])
+AC_DEFUN([AX_PTHREAD], [
+AC_REQUIRE([AC_CANONICAL_HOST])
+AC_REQUIRE([AC_PROG_CC])
+AC_REQUIRE([AC_PROG_SED])
+AC_LANG_PUSH([C])
+ax_pthread_ok=no
+
+# We used to check for pthread.h first, but this fails if pthread.h
+# requires special compiler flags (e.g. on Tru64 or Sequent).
+# It gets checked for in the link test anyway.
+
+# First of all, check if the user has set any of the PTHREAD_LIBS,
+# etcetera environment variables, and if threads linking works using
+# them:
+if test "x$PTHREAD_CFLAGS$PTHREAD_LIBS" != "x"; then
+        ax_pthread_save_CC="$CC"
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        AS_IF([test "x$PTHREAD_CC" != "x"], [CC="$PTHREAD_CC"])
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+        AC_MSG_CHECKING([for pthread_join using $CC $PTHREAD_CFLAGS $PTHREAD_LIBS])
+        AC_LINK_IFELSE([AC_LANG_CALL([], [pthread_join])], [ax_pthread_ok=yes])
+        AC_MSG_RESULT([$ax_pthread_ok])
+        if test "x$ax_pthread_ok" = "xno"; then
+                PTHREAD_LIBS=""
+                PTHREAD_CFLAGS=""
+        fi
+        CC="$ax_pthread_save_CC"
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+fi
+
+# We must check for the threads library under a number of different
+# names; the ordering is very important because some systems
+# (e.g. DEC) have both -lpthread and -lpthreads, where one of the
+# libraries is broken (non-POSIX).
+
+# Create a list of thread flags to try.  Items starting with a "-" are
+# C compiler flags, and other items are library names, except for "none"
+# which indicates that we try without any flags at all, and "pthread-config"
+# which is a program returning the flags for the Pth emulation library.
+
+ax_pthread_flags="pthreads none -Kthread -pthread -pthreads -mthreads pthread --thread-safe -mt pthread-config"
+
+# The ordering *is* (sometimes) important.  Some notes on the
+# individual items follow:
+
+# pthreads: AIX (must check this before -lpthread)
+# none: in case threads are in libc; should be tried before -Kthread and
+#       other compiler flags to prevent continual compiler warnings
+# -Kthread: Sequent (threads in libc, but -Kthread needed for pthread.h)
+# -pthread: Linux/gcc (kernel threads), BSD/gcc (userland threads), Tru64
+#           (Note: HP C rejects this with "bad form for `-t' option")
+# -pthreads: Solaris/gcc (Note: HP C also rejects)
+# -mt: Sun Workshop C (may only link SunOS threads [-lthread], but it
+#      doesn't hurt to check since this sometimes defines pthreads and
+#      -D_REENTRANT too), HP C (must be checked before -lpthread, which
+#      is present but should not be used directly; and before -mthreads,
+#      because the compiler interprets this as "-mt" + "-hreads")
+# -mthreads: Mingw32/gcc, Lynx/gcc
+# pthread: Linux, etcetera
+# --thread-safe: KAI C++
+# pthread-config: use pthread-config program (for GNU Pth library)
+
+case $host_os in
+
+        freebsd*)
+
+        # -kthread: FreeBSD kernel threads (preferred to -pthread since SMP-able)
+        # lthread: LinuxThreads port on FreeBSD (also preferred to -pthread)
+
+        ax_pthread_flags="-kthread lthread $ax_pthread_flags"
+        ;;
+
+        hpux*)
+
+        # From the cc(1) man page: "[-mt] Sets various -D flags to enable
+        # multi-threading and also sets -lpthread."
+
+        ax_pthread_flags="-mt -pthread pthread $ax_pthread_flags"
+        ;;
+
+        openedition*)
+
+        # IBM z/OS requires a feature-test macro to be defined in order to
+        # enable POSIX threads at all, so give the user a hint if this is
+        # not set. (We don't define these ourselves, as they can affect
+        # other portions of the system API in unpredictable ways.)
+
+        AC_EGREP_CPP([AX_PTHREAD_ZOS_MISSING],
+            [
+#            if !defined(_OPEN_THREADS) && !defined(_UNIX03_THREADS)
+             AX_PTHREAD_ZOS_MISSING
+#            endif
+            ],
+            [AC_MSG_WARN([IBM z/OS requires -D_OPEN_THREADS or -D_UNIX03_THREADS to enable pthreads support.])])
+        ;;
+
+        solaris*)
+
+        # On Solaris (at least, for some versions), libc contains stubbed
+        # (non-functional) versions of the pthreads routines, so link-based
+        # tests will erroneously succeed. (N.B.: The stubs are missing
+        # pthread_cleanup_push, or rather a function called by this macro,
+        # so we could check for that, but who knows whether they'll stub
+        # that too in a future libc.)  So we'll check first for the
+        # standard Solaris way of linking pthreads (-mt -lpthread).
+
+        ax_pthread_flags="-mt,pthread pthread $ax_pthread_flags"
+        ;;
+esac
+
+# GCC generally uses -pthread, or -pthreads on some platforms (e.g. SPARC)
+
+AS_IF([test "x$GCC" = "xyes"],
+      [ax_pthread_flags="-pthread -pthreads $ax_pthread_flags"])
+
+# The presence of a feature test macro requesting re-entrant function
+# definitions is, on some systems, a strong hint that pthreads support is
+# correctly enabled
+
+case $host_os in
+        darwin* | hpux* | linux* | osf* | solaris*)
+        ax_pthread_check_macro="_REENTRANT"
+        ;;
+
+        aix*)
+        ax_pthread_check_macro="_THREAD_SAFE"
+        ;;
+
+        *)
+        ax_pthread_check_macro="--"
+        ;;
+esac
+AS_IF([test "x$ax_pthread_check_macro" = "x--"],
+      [ax_pthread_check_cond=0],
+      [ax_pthread_check_cond="!defined($ax_pthread_check_macro)"])
+
+# Are we compiling with Clang?
+
+AC_CACHE_CHECK([whether $CC is Clang],
+    [ax_cv_PTHREAD_CLANG],
+    [ax_cv_PTHREAD_CLANG=no
+     # Note that Autoconf sets GCC=yes for Clang as well as GCC
+     if test "x$GCC" = "xyes"; then
+        AC_EGREP_CPP([AX_PTHREAD_CC_IS_CLANG],
+            [/* Note: Clang 2.7 lacks __clang_[a-z]+__ */
+#            if defined(__clang__) && defined(__llvm__)
+             AX_PTHREAD_CC_IS_CLANG
+#            endif
+            ],
+            [ax_cv_PTHREAD_CLANG=yes])
+     fi
+    ])
+ax_pthread_clang="$ax_cv_PTHREAD_CLANG"
+
+ax_pthread_clang_warning=no
+
+# Clang needs special handling, because older versions handle the -pthread
+# option in a rather... idiosyncratic way
+
+if test "x$ax_pthread_clang" = "xyes"; then
+
+        # Clang takes -pthread; it has never supported any other flag
+
+        # (Note 1: This will need to be revisited if a system that Clang
+        # supports has POSIX threads in a separate library.  This tends not
+        # to be the way of modern systems, but it's conceivable.)
+
+        # (Note 2: On some systems, notably Darwin, -pthread is not needed
+        # to get POSIX threads support; the API is always present and
+        # active.  We could reasonably leave PTHREAD_CFLAGS empty.  But
+        # -pthread does define _REENTRANT, and while the Darwin headers
+        # ignore this macro, third-party headers might not.)
+
+        PTHREAD_CFLAGS="-pthread"
+        PTHREAD_LIBS=
+
+        ax_pthread_ok=yes
+
+        # However, older versions of Clang make a point of warning the user
+        # that, in an invocation where only linking and no compilation is
+        # taking place, the -pthread option has no effect ("argument unused
+        # during compilation").  They expect -pthread to be passed in only
+        # when source code is being compiled.
+        #
+        # Problem is, this is at odds with the way Automake and most other
+        # C build frameworks function, which is that the same flags used in
+        # compilation (CFLAGS) are also used in linking.  Many systems
+        # supported by AX_PTHREAD require exactly this for POSIX threads
+        # support, and in fact it is often not straightforward to specify a
+        # flag that is used only in the compilation phase and not in
+        # linking.  Such a scenario is extremely rare in practice.
+        #
+        # Even though use of the -pthread flag in linking would only print
+        # a warning, this can be a nuisance for well-run software projects
+        # that build with -Werror.  So if the active version of Clang has
+        # this misfeature, we search for an option to squash it.
+
+        AC_CACHE_CHECK([whether Clang needs flag to prevent "argument unused" warning when linking with -pthread],
+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG],
+            [ax_cv_PTHREAD_CLANG_NO_WARN_FLAG=unknown
+             # Create an alternate version of $ac_link that compiles and
+             # links in two steps (.c -> .o, .o -> exe) instead of one
+             # (.c -> exe), because the warning occurs only in the second
+             # step
+             ax_pthread_save_ac_link="$ac_link"
+             ax_pthread_sed='s/conftest\.\$ac_ext/conftest.$ac_objext/g'
+             ax_pthread_link_step=`$as_echo "$ac_link" | sed "$ax_pthread_sed"`
+             ax_pthread_2step_ac_link="($ac_compile) && (echo ==== >&5) && ($ax_pthread_link_step)"
+             ax_pthread_save_CFLAGS="$CFLAGS"
+             for ax_pthread_try in '' -Qunused-arguments -Wno-unused-command-line-argument unknown; do
+                AS_IF([test "x$ax_pthread_try" = "xunknown"], [break])
+                CFLAGS="-Werror -Wunknown-warning-option $ax_pthread_try -pthread $ax_pthread_save_CFLAGS"
+                ac_link="$ax_pthread_save_ac_link"
+                AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],
+                    [ac_link="$ax_pthread_2step_ac_link"
+                     AC_LINK_IFELSE([AC_LANG_SOURCE([[int main(void){return 0;}]])],
+                         [break])
+                    ])
+             done
+             ac_link="$ax_pthread_save_ac_link"
+             CFLAGS="$ax_pthread_save_CFLAGS"
+             AS_IF([test "x$ax_pthread_try" = "x"], [ax_pthread_try=no])
+             ax_cv_PTHREAD_CLANG_NO_WARN_FLAG="$ax_pthread_try"
+            ])
+
+        case "$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG" in
+                no | unknown) ;;
+                *) PTHREAD_CFLAGS="$ax_cv_PTHREAD_CLANG_NO_WARN_FLAG $PTHREAD_CFLAGS" ;;
+        esac
+
+fi # $ax_pthread_clang = yes
+
+if test "x$ax_pthread_ok" = "xno"; then
+for ax_pthread_try_flag in $ax_pthread_flags; do
+
+        case $ax_pthread_try_flag in
+                none)
+                AC_MSG_CHECKING([whether pthreads work without any flags])
+                ;;
+
+                -mt,pthread)
+                AC_MSG_CHECKING([whether pthreads work with -mt -lpthread])
+                PTHREAD_CFLAGS="-mt"
+                PTHREAD_LIBS="-lpthread"
+                ;;
+
+                -*)
+                AC_MSG_CHECKING([whether pthreads work with $ax_pthread_try_flag])
+                PTHREAD_CFLAGS="$ax_pthread_try_flag"
+                ;;
+
+                pthread-config)
+                AC_CHECK_PROG([ax_pthread_config], [pthread-config], [yes], [no])
+                AS_IF([test "x$ax_pthread_config" = "xno"], [continue])
+                PTHREAD_CFLAGS="`pthread-config --cflags`"
+                PTHREAD_LIBS="`pthread-config --ldflags` `pthread-config --libs`"
+                ;;
+
+                *)
+                AC_MSG_CHECKING([for the pthreads library -l$ax_pthread_try_flag])
+                PTHREAD_LIBS="-l$ax_pthread_try_flag"
+                ;;
+        esac
+
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+
+        # Check for various functions.  We must include pthread.h,
+        # since some functions may be macros.  (On the Sequent, we
+        # need a special flag -Kthread to make this header compile.)
+        # We check for pthread_join because it is in -lpthread on IRIX
+        # while pthread_create is in libc.  We check for pthread_attr_init
+        # due to DEC craziness with -lpthreads.  We check for
+        # pthread_cleanup_push because it is one of the few pthread
+        # functions on Solaris that doesn't have a non-functional libc stub.
+        # We try pthread_create on general principles.
+
+        AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>
+#                       if $ax_pthread_check_cond
+#                        error "$ax_pthread_check_macro must be defined"
+#                       endif
+                        static void routine(void *a) { a = 0; }
+                        static void *start_routine(void *a) { return a; }],
+                       [pthread_t th; pthread_attr_t attr;
+                        pthread_create(&th, 0, start_routine, 0);
+                        pthread_join(th, 0);
+                        pthread_attr_init(&attr);
+                        pthread_cleanup_push(routine, 0);
+                        pthread_cleanup_pop(0) /* ; */])],
+            [ax_pthread_ok=yes],
+            [])
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        AC_MSG_RESULT([$ax_pthread_ok])
+        AS_IF([test "x$ax_pthread_ok" = "xyes"], [break])
+
+        PTHREAD_LIBS=""
+        PTHREAD_CFLAGS=""
+done
+fi
+
+# Various other checks:
+if test "x$ax_pthread_ok" = "xyes"; then
+        ax_pthread_save_CFLAGS="$CFLAGS"
+        ax_pthread_save_LIBS="$LIBS"
+        CFLAGS="$CFLAGS $PTHREAD_CFLAGS"
+        LIBS="$PTHREAD_LIBS $LIBS"
+
+        # Detect AIX lossage: JOINABLE attribute is called UNDETACHED.
+        AC_CACHE_CHECK([for joinable pthread attribute],
+            [ax_cv_PTHREAD_JOINABLE_ATTR],
+            [ax_cv_PTHREAD_JOINABLE_ATTR=unknown
+             for ax_pthread_attr in PTHREAD_CREATE_JOINABLE PTHREAD_CREATE_UNDETACHED; do
+                 AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <pthread.h>],
+                                                 [int attr = $ax_pthread_attr; return attr /* ; */])],
+                                [ax_cv_PTHREAD_JOINABLE_ATTR=$ax_pthread_attr; break],
+                                [])
+             done
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xunknown" && \
+               test "x$ax_cv_PTHREAD_JOINABLE_ATTR" != "xPTHREAD_CREATE_JOINABLE" && \
+               test "x$ax_pthread_joinable_attr_defined" != "xyes"],
+              [AC_DEFINE_UNQUOTED([PTHREAD_CREATE_JOINABLE],
+                                  [$ax_cv_PTHREAD_JOINABLE_ATTR],
+                                  [Define to necessary symbol if this constant
+                                   uses a non-standard name on your system.])
+               ax_pthread_joinable_attr_defined=yes
+              ])
+
+        AC_CACHE_CHECK([whether more special flags are required for pthreads],
+            [ax_cv_PTHREAD_SPECIAL_FLAGS],
+            [ax_cv_PTHREAD_SPECIAL_FLAGS=no
+             case $host_os in
+             solaris*)
+             ax_cv_PTHREAD_SPECIAL_FLAGS="-D_POSIX_PTHREAD_SEMANTICS"
+             ;;
+             esac
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_SPECIAL_FLAGS" != "xno" && \
+               test "x$ax_pthread_special_flags_added" != "xyes"],
+              [PTHREAD_CFLAGS="$ax_cv_PTHREAD_SPECIAL_FLAGS $PTHREAD_CFLAGS"
+               ax_pthread_special_flags_added=yes])
+
+        AC_CACHE_CHECK([for PTHREAD_PRIO_INHERIT],
+            [ax_cv_PTHREAD_PRIO_INHERIT],
+            [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <pthread.h>]],
+                                             [[int i = PTHREAD_PRIO_INHERIT;]])],
+                            [ax_cv_PTHREAD_PRIO_INHERIT=yes],
+                            [ax_cv_PTHREAD_PRIO_INHERIT=no])
+            ])
+        AS_IF([test "x$ax_cv_PTHREAD_PRIO_INHERIT" = "xyes" && \
+               test "x$ax_pthread_prio_inherit_defined" != "xyes"],
+              [AC_DEFINE([HAVE_PTHREAD_PRIO_INHERIT], [1], [Have PTHREAD_PRIO_INHERIT.])
+               ax_pthread_prio_inherit_defined=yes
+              ])
+
+        CFLAGS="$ax_pthread_save_CFLAGS"
+        LIBS="$ax_pthread_save_LIBS"
+
+        # More AIX lossage: compile with *_r variant
+        if test "x$GCC" != "xyes"; then
+            case $host_os in
+                aix*)
+                AS_CASE(["x/$CC"],
+                    [x*/c89|x*/c89_128|x*/c99|x*/c99_128|x*/cc|x*/cc128|x*/xlc|x*/xlc_v6|x*/xlc128|x*/xlc128_v6],
+                    [#handle absolute path differently from PATH based program lookup
+                     AS_CASE(["x$CC"],
+                         [x/*],
+                         [AS_IF([AS_EXECUTABLE_P([${CC}_r])],[PTHREAD_CC="${CC}_r"])],
+                         [AC_CHECK_PROGS([PTHREAD_CC],[${CC}_r],[$CC])])])
+                ;;
+            esac
+        fi
+fi
+
+test -n "$PTHREAD_CC" || PTHREAD_CC="$CC"
+
+AC_SUBST([PTHREAD_LIBS])
+AC_SUBST([PTHREAD_CFLAGS])
+AC_SUBST([PTHREAD_CC])
+
+# Finally, execute ACTION-IF-FOUND/ACTION-IF-NOT-FOUND:
+if test "x$ax_pthread_ok" = "xyes"; then
+        ifelse([$1],,[AC_DEFINE([HAVE_PTHREAD],[1],[Define if you have POSIX threads libraries and header files.])],[$1])
+        :
+else
+        ax_pthread_ok=no
+        $2
+fi
+AC_LANG_POP
+])dnl AX_PTHREAD
+
+# ===========================================================================
+#    https://www.gnu.org/software/autoconf-archive/ax_require_defined.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   AX_REQUIRE_DEFINED(MACRO)
+#
+# DESCRIPTION
+#
+#   AX_REQUIRE_DEFINED is a simple helper for making sure other macros have
+#   been defined and thus are available for use.  This avoids random issues
+#   where a macro isn't expanded.  Instead the configure script emits a
+#   non-fatal:
+#
+#     ./configure: line 1673: AX_CFLAGS_WARN_ALL: command not found
+#
+#   It's like AC_REQUIRE except it doesn't expand the required macro.
+#
+#   Here's an example:
+#
+#     AX_REQUIRE_DEFINED([AX_CHECK_LINK_FLAG])
+#
+# LICENSE
+#
+#   Copyright (c) 2014 Mike Frysinger <vapier@gentoo.org>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 2
+
+AC_DEFUN([AX_REQUIRE_DEFINED], [dnl
+  m4_ifndef([$1], [m4_fatal([macro ]$1[ is not defined; is a m4 file missing?])])
+])dnl AX_REQUIRE_DEFINED
+
diff --git a/src/Makefile.am b/src/Makefile.am
index 255a2b8..9b3c585 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -30,12 +30,20 @@ CLEANFILES = stunnel3
 stunnel_CPPFLAGS = -I$(SYSROOT)/usr/kerberos/include
 
 # Additional preprocessor definitions
+if WOLFSSL
+stunnel_CPPFLAGS += -I$(SSLDIR)/include/wolfssl -I$(SSLDIR)/include
+else
 stunnel_CPPFLAGS += -I$(SSLDIR)/include
+endif
 stunnel_CPPFLAGS += -DLIBDIR='"$(pkglibdir)"'
 stunnel_CPPFLAGS += -DCONFDIR='"$(sysconfdir)/stunnel"'
 
 # TLS library
+if WOLFSSL
+stunnel_LDFLAGS = -L$(SSLDIR)/lib64 -L$(SSLDIR)/lib -lwolfssl
+else
 stunnel_LDFLAGS = -L$(SSLDIR)/lib64 -L$(SSLDIR)/lib -lssl -lcrypto
+endif
 
 # stunnel3 script
 edit = sed \
@@ -53,8 +61,13 @@ libstunnel_la_LDFLAGS = -avoid-version
 # Win32 executables                                                           #
 ###############################################################################
 
+if WOLFSSL
+mingw:
+	$(MAKE) -f $(srcdir)/mingw_wolfssl.mk srcdir=$(srcdir) win32_arch=win32 win32_targetcpu=i686 win32_mingw=mingw
+else
 mingw:
 	$(MAKE) -f $(srcdir)/mingw.mk srcdir=$(srcdir) win32_arch=win32 win32_targetcpu=i686 win32_mingw=mingw
+endif
 
 mingw64:
 	$(MAKE) -f $(srcdir)/mingw.mk srcdir=$(srcdir) win32_arch=win64 win32_targetcpu=x86_64 win32_mingw=mingw64
diff --git a/src/common.h b/src/common.h
index 997e66e..797a517 100644
--- a/src/common.h
+++ b/src/common.h
@@ -47,15 +47,22 @@
 #define LIBWRAP_CLIENTS 5
 
 /* CPU stack size */
-#define DEFAULT_STACK_SIZE 65536
+#ifdef WITH_WOLFSSL
+    /* Default option for wolfssl is Tom's fastmath with timing resistance
+     * which providers far greater security. This can be reduced to
+     * 65536 if not using TFM timing resistance. */
+    #define DEFAULT_STACK_SIZE 131072
+#else
+    #define DEFAULT_STACK_SIZE 65536
+#endif
 /* #define DEBUG_STACK_SIZE */
 
 /* I/O buffer size: 18432 (0x4800) is the maximum size of TLS record payload */
 #define BUFFSIZE 18432
 
 /* how many bytes of random input to read from files for PRNG */
-/* security margin is huge to compensate for flawed entropy */
-#define RANDOM_BYTES 1024
+/* OpenSSL likes at least 128 bits, so 64 bytes seems plenty. */
+#define RANDOM_BYTES 64
 
 /**************************************** debugging */
 
@@ -414,6 +421,21 @@ extern char *sys_errlist[];
 #define S_ISREG(m) (((m)&S_IFMT)==S_IFREG)
 #endif
 
+/**************************************** wolfSSL headers */
+#ifdef WITH_WOLFSSL
+#include <wolfssl/options.h>
+#include <wolfssl/openssl/ssl.h>
+#include <wolfssl/wolfcrypt/wc_port.h>
+#include <wolfssl/wolfcrypt/coding.h>
+#ifdef WOLFSSL_DEBUG_ON
+#include <wolfssl/wolfcrypt/logging.h>
+#endif /* WOLFSSL_DEBUG_ON */
+#include <wolfssl/wolfcrypt/dh.h>
+#include <wolfssl/wolfcrypt/error-crypt.h>
+#include <wolfssl/openssl/ec.h>
+#include <wolfssl/openssl/pem.h>
+#endif /* defined(WITH_WOLFSSL) */
+
 /**************************************** OpenSSL headers */
 
 /* TODO: remove this after migrating to the OpenSSL 3.0 API */
@@ -470,6 +492,53 @@ extern char *sys_errlist[];
 #define OPENSSL_NO_TLS1_3
 #endif /* OpenSSL older than 1.1.1 */
 
+/* WOLFSSL_SPECIFIC ifdefs */
+#ifdef WITH_WOLFSSL
+
+#if defined(WOLFSSL_TLS13) && defined(OPENSSL_NO_TLS1_3)
+#undef OPENSSL_NO_TLS1_3
+#endif
+
+#ifndef WOLFSSL_ALLOW_SSLV3
+#ifndef OPENSSL_NO_SSL3
+#define OPENSSL_NO_SSL3
+#endif /* !defined(OPENSSL_NO_SSL3) */
+#endif /*WOLFSSL_ALLOW_SSLv3 */
+
+#ifndef OPENSSL_NO_ENGINE
+#define OPENSSL_NO_ENGINE
+#endif /* OPENSSL_NO_ENGINE */
+
+#ifndef OPENSSL_NO_COMP
+#define OPENSSL_NO_COMP
+#endif /* OPENSSL_NO_COMP */
+
+#ifndef OPENSSL_NO_SSL2
+#define OPENSSL_NO_SSL2
+#endif /* !defined(OPENSSL_NO_SSL2) */
+
+#ifndef CRYPTO_w_lock
+#define CRYPTO_w_lock CRYPTO_THREAD_lock
+#endif /* CRYPTO_w_lock */
+
+#ifndef CRYPTO_w_unlock
+#define CRYPTO_w_unlock CRYPTO_THREAD_unlock
+#endif /* CRYPTO_w_lock */
+
+#if defined(NO_OLD_TLS) || !defined(WOLFSSL_ALLOW_TLSV10)
+#define OPENSSL_NO_TLS1
+#endif
+
+#ifdef NO_OLD_TLS
+#define OPENSSL_NO_TLS1_1
+#endif
+
+#ifdef WOLFSSL_NO_TLS12
+#define OPENSSL_NO_TLS1_2
+#endif
+
+#endif /* defined (WITH_WOLFSSL) */
+
 #ifdef USE_WIN32
 #define USE_FIPS
 #endif
diff --git a/src/cron.c b/src/cron.c
index e565456..47d08fc 100644
--- a/src/cron.c
+++ b/src/cron.c
@@ -52,7 +52,7 @@ NOEXPORT unsigned __stdcall cron_thread(void *arg);
 #ifdef USE_OS_THREADS
 NOEXPORT void cron_worker(void);
 #ifndef OPENSSL_NO_DH
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
 NOEXPORT void cron_dh_param(BN_GENCB *);
 NOEXPORT BN_GENCB *cron_bn_gencb(void);
 NOEXPORT int bn_callback(int, int, BN_GENCB *);
@@ -141,19 +141,19 @@ int cron_init() {
 NOEXPORT void cron_worker(void) {
     time_t now, then;
     int delay;
-#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
     BN_GENCB *bn_gencb;
 #endif
 
     s_log(LOG_DEBUG, "Cron thread initialized");
-#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if !defined(OPENSSL_NO_DH) && OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
     bn_gencb=cron_bn_gencb();
 #endif
     time(&then);
     for(;;) {
         s_log(LOG_INFO, "Executing cron jobs");
 #ifndef OPENSSL_NO_DH
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
         cron_dh_param(bn_gencb);
 #else /* OpenSSL older than 0.9.8 */
         cron_dh_param();
@@ -182,7 +182,7 @@ NOEXPORT void cron_worker(void) {
 
 #ifndef OPENSSL_NO_DH
 
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
 NOEXPORT void cron_dh_param(BN_GENCB *bn_gencb) {
 #else /* OpenSSL older than 0.9.8 */
 NOEXPORT void cron_dh_param(void) {
@@ -194,7 +194,7 @@ NOEXPORT void cron_dh_param(void) {
         return;
 
     s_log(LOG_NOTICE, "Updating DH parameters");
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
     /* generate 2048-bit DH parameters */
     dh=DH_new();
     if(!dh) {
@@ -229,7 +229,7 @@ NOEXPORT void cron_dh_param(void) {
     s_log(LOG_NOTICE, "DH parameters updated");
 }
 
-#if OPENSSL_VERSION_NUMBER>=0x0090800fL
+#if OPENSSL_VERSION_NUMBER>=0x0090800fL && !defined(WITH_WOLFSSL)
 
 NOEXPORT BN_GENCB *cron_bn_gencb(void) {
 #if OPENSSL_VERSION_NUMBER>=0x10100000L
diff --git a/src/ctx.c b/src/ctx.c
index c2dd5e5..1d52567 100644
--- a/src/ctx.c
+++ b/src/ctx.c
@@ -63,7 +63,9 @@ NOEXPORT int matches_wildcard(const char *, const char *);
 /* DH/ECDH */
 #ifndef OPENSSL_NO_DH
 NOEXPORT int dh_init(SERVICE_OPTIONS *);
+#ifndef WITH_WOLFSSL
 NOEXPORT DH *dh_read(char *);
+#endif /* WITH_WOLFSSL  */
 #endif /* OPENSSL_NO_DH */
 #ifndef OPENSSL_NO_ECDH
 NOEXPORT int ecdh_init(SERVICE_OPTIONS *);
@@ -133,7 +135,7 @@ NOEXPORT void sslerror_log(unsigned long, const char *, int, const char *);
 
 /**************************************** initialize section->ctx */
 
-#if OPENSSL_VERSION_NUMBER>=0x10100000L
+#if OPENSSL_VERSION_NUMBER>=0x10100000L && !defined(WITH_WOLFSSL)
 typedef long unsigned SSL_OPTIONS_TYPE;
 #else
 typedef long SSL_OPTIONS_TYPE;
@@ -204,7 +206,7 @@ int context_init(SERVICE_OPTIONS *section) { /* init TLS context */
 
     /* ciphers */
     if(section->cipher_list) {
-        s_log(LOG_DEBUG, "Ciphers: %s", section->cipher_list);
+        s_log(LOG_INFO, "Ciphers: %s", section->cipher_list);
         if(!SSL_CTX_set_cipher_list(section->ctx, section->cipher_list)) {
             sslerror("SSL_CTX_set_cipher_list");
             return 1; /* FAILED */
@@ -355,7 +357,7 @@ NOEXPORT int servername_cb(SSL *ssl, int *ad, void *arg) {
     (void)arg; /* squash the unused parameter warning */
 
     /* handle trivial cases first */
-    if(!c->opt->servername_list_head) {
+    if(!c || !c->opt->servername_list_head) {
         s_log(LOG_DEBUG, "SNI: no virtual services defined");
         return SSL_TLSEXT_ERR_OK;
     }
@@ -415,13 +417,22 @@ NOEXPORT int matches_wildcard(const char *servername, const char *pattern) {
 
 #ifndef OPENSSL_NO_DH
 
-#if OPENSSL_VERSION_NUMBER<0x10100000L
+#if(OPENSSL_VERSION_NUMBER<0x10100000L) && !defined(WITH_WOLFSSL)
 NOEXPORT STACK_OF(SSL_CIPHER) *SSL_CTX_get_ciphers(const SSL_CTX *ctx) {
     return ctx->cipher_list;
 }
 #endif
 
 NOEXPORT int dh_init(SERVICE_OPTIONS *section) {
+#ifdef WITH_WOLFSSL
+    s_log(LOG_DEBUG, "DH initialization");
+    if(wolfSSL_CTX_SetTmpDH_file(section->ctx, section->cert,
+               SSL_FILETYPE_ASN1) == SSL_SUCCESS) { /* DH file loading failed */
+        return 0;
+     } else {
+        s_log(LOG_DEBUG, "Error loading DH params from file: %s", section->cert);
+    }
+#else
     DH *dh=NULL;
     int i, n;
     char description[128];
@@ -465,6 +476,8 @@ NOEXPORT int dh_init(SERVICE_OPTIONS *section) {
         DH_free(dh);
         return 0; /* OK */
     }
+#endif /* WITH_WOLFSSL */
+
     CRYPTO_THREAD_read_lock(stunnel_locks[LOCK_DH]);
     SSL_CTX_set_tmp_dh(section->ctx, dh_params);
     CRYPTO_THREAD_unlock(stunnel_locks[LOCK_DH]);
@@ -474,6 +487,7 @@ NOEXPORT int dh_init(SERVICE_OPTIONS *section) {
     return 0; /* OK */
 }
 
+#ifndef WITH_WOLFSSL
 NOEXPORT DH *dh_read(char *cert) {
     DH *dh;
     BIO *bio;
@@ -498,6 +512,7 @@ NOEXPORT DH *dh_read(char *cert) {
     s_log(LOG_DEBUG, "Using DH parameters from %s", cert);
     return dh;
 }
+#endif /* WITH_WOLFSSL */
 
 #endif /* OPENSSL_NO_DH */
 
@@ -505,7 +520,7 @@ NOEXPORT DH *dh_read(char *cert) {
 
 #ifndef OPENSSL_NO_ECDH
 
-#if OPENSSL_VERSION_NUMBER < 0x10101000L
+#if OPENSSL_VERSION_NUMBER < 0x10101000L && !defined(WITH_WOLFSSL)
 /* simplified version that only supports a single curve */
 NOEXPORT int SSL_CTX_set1_groups_list(SSL_CTX *ctx, char *list) {
     int nid;
@@ -529,9 +544,15 @@ NOEXPORT int SSL_CTX_set1_groups_list(SSL_CTX *ctx, char *list) {
     EC_KEY_free(ecdh);
     return 1; /* OK */
 }
-#endif /* OpenSSL version < 1.1.1 */
+#endif /* OPENSSL_VERSION_NUMBER < 0x10101000L && !defined(WITH_WOLFSSL)  */
 
 NOEXPORT int ecdh_init(SERVICE_OPTIONS *section) {
+#ifdef WITH_WOLFSSL
+    /* wolfSSL automatically detects ecdh parameters from ECC key file.
+     * No need to load explicitly */
+    (void)section;
+    return 0;
+#else
     s_log(LOG_DEBUG, "ECDH initialization");
     if(!SSL_CTX_set1_groups_list(section->ctx, section->curves)) {
         s_log(LOG_ERR, "Invalid groups list in 'curves'");
@@ -539,6 +560,7 @@ NOEXPORT int ecdh_init(SERVICE_OPTIONS *section) {
     }
     s_log(LOG_DEBUG, "ECDH initialized with curves %s", section->curves);
     return 0; /* OK */
+#endif /* WITH_WOLFSSL */
 }
 
 #endif /* OPENSSL_NO_ECDH */
@@ -681,7 +703,7 @@ NOEXPORT unsigned psk_client_callback(SSL *ssl, const char *hint,
 
     (void)hint; /* squash the unused parameter warning */
     c=SSL_get_ex_data(ssl, index_ssl_cli);
-    if(!c->opt->psk_selected) {
+    if(!c || !c->opt->psk_selected) {
         s_log(LOG_ERR, "INTERNAL ERROR: No PSK identity selected");
         return 0;
     }
@@ -711,6 +733,10 @@ NOEXPORT unsigned psk_server_callback(SSL *ssl, const char *identity,
     PSK_KEYS *found;
 
     c=SSL_get_ex_data(ssl, index_ssl_cli);
+    if(!c) {
+        s_log(LOG_INFO, "SSL_get_ex_data returned NULL");
+        return 0;
+    }
     found=psk_find(&c->opt->psk_sorted, identity);
     if(!found) {
         s_log(LOG_INFO, "PSK identity not found (session resumption?)");
@@ -1000,6 +1026,10 @@ NOEXPORT void set_prompt(const char *name) {
 }
 
 NOEXPORT int ui_retry() {
+#ifdef WITH_WOLFSSL
+    /* WOLFSSL does not support ERR_peek_error */
+    return 0;
+#else
     unsigned long err=ERR_peek_error();
 
     switch(ERR_GET_LIB(err)) {
@@ -1086,6 +1116,7 @@ NOEXPORT int ui_retry() {
         s_log(LOG_ERR, "Unhandled error library: %d", ERR_GET_LIB(err));
         return 0;
     }
+#endif /* WITH_WOLFSSL */
 }
 
 /**************************************** session tickets */
@@ -1216,11 +1247,13 @@ NOEXPORT int ssl_tlsext_ticket_key_cb(SSL *ssl, unsigned char *key_name,
     const EVP_CIPHER *cipher;
     int iv_len;
 
+#ifndef WITH_WOLFSSL
     (void)key_name; /* squash the unused parameter warning */
+#endif
     s_log(LOG_DEBUG, "Session ticket processing callback");
 
     c=SSL_get_ex_data(ssl, index_ssl_cli);
-    if(!HMAC_Init_ex(hctx, (const unsigned char *)(c->opt->ticket_mac->key_val),
+    if(!c || !HMAC_Init_ex(hctx, (const unsigned char *)(c->opt->ticket_mac->key_val),
         c->opt->ticket_mac->key_len, EVP_sha256(), NULL)) {
         s_log(LOG_ERR, "HMAC_Init_ex failed");
         return -1;
@@ -1241,6 +1274,9 @@ NOEXPORT int ssl_tlsext_ticket_key_cb(SSL *ssl, unsigned char *key_name,
             s_log(LOG_ERR, "EVP_EncryptInit_ex failed");
             return -1;
         }
+#ifdef WITH_WOLFSSL
+        XMEMCPY(key_name, "stunnel ticket", sizeof("stunnel ticket"));
+#endif
     } else /* retrieve session */
         if(!EVP_DecryptInit_ex(ctx, cipher, NULL,
             (const unsigned char *)(c->opt->ticket_key->key_val), iv)) {
@@ -1266,6 +1302,11 @@ NOEXPORT int sess_new_cb(SSL *ssl, SSL_SESSION *sess) {
     s_log(LOG_DEBUG, "New session callback");
     c=SSL_get_ex_data(ssl, index_ssl_cli);
 
+    if (!c) {
+        s_log(LOG_ERR, "SSL_get_ex_data returned NULL");
+        return 0;
+    }
+
     new_chain(c); /* new session -> we may have a new peer certificate chain */
 
     if(c->opt->option.client)
@@ -1300,6 +1341,46 @@ void print_session_id(SSL_SESSION *sess) {
 }
 
 NOEXPORT void new_chain(CLI *c) {
+#ifdef WITH_WOLFSSL
+    char* chain;
+    WOLFSSL_X509_CHAIN* certChain;
+    int i, certSz, idx, size;
+
+    if(c->opt->chain) /* already cached */
+        return; /* this race condition is safe to ignore */
+
+    certChain = wolfSSL_get_peer_chain(c->ssl);
+    if(!certChain || wolfSSL_get_chain_count(certChain) == 0) {
+        s_log(LOG_INFO, "No peer certificate received");
+        return;
+    }
+
+    for(size=0, i=0; i < wolfSSL_get_chain_count(certChain); ++i) {
+        if(wolfSSL_get_chain_cert_pem(certChain, i, NULL, 0, &certSz)
+                != LENGTH_ONLY_E) {
+            s_log(LOG_ERR, "Unable to cache peer cert");
+            return;
+        }
+        size+=certSz;
+    }
+
+    chain=str_alloc_detached((size_t)size+1); /* +1 for '\0' */
+
+    idx = 0;
+    for(i=0; i <wolfSSL_get_chain_count(certChain); ++i) {
+        if(wolfSSL_get_chain_cert_pem(certChain, i, (unsigned char*)chain+idx,
+                   size-idx, &certSz) != SSL_SUCCESS){
+            s_log(LOG_ERR, "Unable to cache peer cert");
+            str_free(chain);
+            return;
+        }
+        idx+=certSz;
+    }
+    chain[size]='\0';
+    c->opt->chain=chain; /* this race condition is safe to ignore */
+    ui_new_chain(c->opt->section_number);
+    s_log(LOG_DEBUG, "Peer certificate was cached (%d bytes)", size);
+#else
     BIO *bio;
     int i, len;
     X509 *peer_cert;
@@ -1343,6 +1424,7 @@ NOEXPORT void new_chain(CLI *c) {
     c->opt->chain=chain; /* this race condition is safe to ignore */
     ui_new_chain(c->opt->section_number);
     s_log(LOG_DEBUG, "Peer certificate was cached (%d bytes)", len);
+#endif /* ifdef WITH_WOLFSSL */
 }
 
 /* cache client sessions */
@@ -1384,7 +1466,7 @@ NOEXPORT SSL_SESSION *sess_get_cb(SSL *ssl,
     s_log(LOG_DEBUG, "Get session callback");
     *do_copy=0; /* allow the session to be freed automatically */
     c=SSL_get_ex_data(ssl, index_ssl_cli);
-    if(c->opt->option.sessiond)
+    if(c && c->opt->option.sessiond)
         return cache_get(ssl, key, key_len);
     return NULL; /* no session to resume */
 }
@@ -1394,7 +1476,7 @@ NOEXPORT void sess_remove_cb(SSL_CTX *ctx, SSL_SESSION *sess) {
 
     s_log(LOG_DEBUG, "Remove session callback");
     opt=SSL_CTX_get_ex_data(ctx, index_ssl_ctx_opt);
-    if(opt->option.sessiond)
+    if(opt && opt->option.sessiond)
         cache_remove(ctx, sess);
 }
 
@@ -1509,6 +1591,13 @@ NOEXPORT void cache_transfer(SSL_CTX *ctx, const u_char type,
 
     /* retrieve pointer to the section structure of this ctx */
     section=SSL_CTX_get_ex_data(ctx, index_ssl_ctx_opt);
+    if(!section) {
+        s_log(LOG_ERR, "cache_transfer: section is NULL");
+        closesocket(s);
+        str_free(packet);
+        return;
+    }
+
     if(sendto(s, (void *)packet,
 #ifdef USE_WIN32
             (int)
@@ -1591,6 +1680,7 @@ NOEXPORT void info_callback(const SSL *ssl, int where, int ret) {
         s_log(LOG_DEBUG, "state = %x", state);
 #endif
 
+#ifndef WITH_WOLFSSL /* wolfSSL doesn't support get_state */
         /* log the client certificate request (if received) */
 #ifndef SSL3_ST_CR_CERT_REQ_A
         if(state==TLS_ST_CR_CERT_REQ)
@@ -1605,6 +1695,7 @@ NOEXPORT void info_callback(const SSL *ssl, int where, int ret) {
 #endif
             if(!SSL_get_client_CA_list(ssl))
                 s_log(LOG_INFO, "Client certificate not requested");
+#endif /* WITH_WOLFSSL */
 
         /* prevent renegotiation DoS attack */
         if((where&SSL_CB_HANDSHAKE_DONE)
@@ -1643,7 +1734,7 @@ NOEXPORT void info_callback(const SSL *ssl, int where, int ret) {
             SSL_alert_type_string_long(ret),
             SSL_alert_desc_string_long(ret));
     } else if(where==SSL_CB_HANDSHAKE_DONE) {
-        ctx=SSL_get_SSL_CTX(ssl);
+        ctx=SSL_get_SSL_CTX((SSL*)ssl);
         if(c->opt->option.client) {
             s_log(LOG_DEBUG, "%6ld client connect(s) requested",
                 SSL_CTX_sess_connect(ctx));
diff --git a/src/log.c b/src/log.c
index 54b17f7..1d46560 100644
--- a/src/log.c
+++ b/src/log.c
@@ -254,6 +254,13 @@ void log_flush(LOG_MODE new_mode) {
     CRYPTO_THREAD_unlock(stunnel_locks[LOCK_LOG_MODE]);
 }
 
+#ifdef WITH_WOLFSSL
+void wolfSSL_s_log(const int level, const char *const format)
+{
+    s_log(level+3, "wolfSSL Logs: %s", format);
+}
+#endif
+
 NOEXPORT void log_raw(SERVICE_OPTIONS *opt,
         int level, char *stamp, char *id, char *text) {
     char *line;
diff --git a/src/mingw_wolfssl.mk b/src/mingw_wolfssl.mk
new file mode 100644
index 0000000..7637107
--- /dev/null
+++ b/src/mingw_wolfssl.mk
@@ -0,0 +1,70 @@
+## mingw/mingw64 Makefile
+# by Michal Trojnara 1998-2020
+
+# 32-bit Windows
+#win32_arch=win32
+#win32_targetcpu=i686
+#win32_mingw=mingw
+
+# 64-bit Windows
+#win32_arch=win64
+#win32_targetcpu=x86_64
+#win32_mingw=mingw64
+
+bindir = ../bin/$(win32_arch)
+objdir = ../obj/$(win32_arch)
+
+win32_ssl_dir = /opt/wolfssl_dll
+win32_cppflags = -I$(win32_ssl_dir)/include -I$(win32_ssl_dir)/include/wolfssl
+win32_cflags = -g -mthreads -O2
+#win32_cflags += -fstack-protector
+win32_cflags += -Wall -Wextra -Wpedantic -Wformat=2 -Wconversion -Wno-long-long
+win32_cflags += -D_FORTIFY_SOURCE=2 -DUNICODE -D_UNICODE -DWITH_WOLFSSL
+win32_ldflags = -g -mthreads
+#win32_ldflags += -fstack-protector
+# -fstack-protector is broken (at least in x86_64-w64-mingw32-gcc 8.2.0)
+
+# compiling with -D_FORTIFY_SOURCE=2 may require linking with -lssp
+win32_common_libs = -lws2_32 -lkernel32 -lssp
+win32_ssl_libs = -L$(win32_ssl_dir)/lib -lwolfssl
+win32_gui_libs = $(win32_common_libs) -lgdi32 -lpsapi $(win32_ssl_libs)
+win32_cli_libs = $(win32_common_libs) $(win32_ssl_libs)
+
+common_headers = common.h prototypes.h version.h
+win32_common = tls str file client log options protocol network resolver
+win32_common += ssl ctx verify sthreads fd dhparam cron stunnel
+win32_gui = ui_win_gui resources
+win32_cli = ui_win_cli
+win32_common_objs = $(addsuffix .o, $(addprefix $(objdir)/, $(win32_common)))
+win32_gui_objs = $(addsuffix .o, $(addprefix $(objdir)/, $(win32_gui)))
+win32_cli_objs = $(addsuffix .o, $(addprefix $(objdir)/, $(win32_cli)))
+
+win32_prefix = $(win32_targetcpu)-w64-mingw32-
+win32_cc = $(win32_prefix)gcc
+win32_windres = $(win32_prefix)windres
+
+all: mkdirs $(bindir)/stunnel.exe $(bindir)/tstunnel.exe
+
+mkdirs:
+	mkdir -p $(bindir) $(objdir)
+
+$(bindir)/stunnel.exe: $(win32_common_objs) $(win32_gui_objs)
+	$(win32_cc) -mwindows $(win32_ldflags) -o $(bindir)/stunnel.exe $(win32_common_objs) $(win32_gui_objs) $(win32_gui_libs)
+#	-$(srcdir)/../sign/sign.sh $(bindir)/stunnel.exe
+
+$(bindir)/tstunnel.exe: $(win32_common_objs) $(win32_cli_objs)
+	$(win32_cc) $(win32_ldflags) -o $(bindir)/tstunnel.exe $(win32_common_objs) $(win32_cli_objs) $(win32_cli_libs)
+# 	-$(srcdir)/../sign/sign.sh $(bindir)/tstunnel.exe
+	
+
+$(objdir)/%.o: $(srcdir)/%.c
+	$(win32_cc) -c $(win32_cppflags) $(win32_cflags) -o $@ $<
+
+$(objdir)/%.o: $(common_headers)
+
+$(win32_gui_objs): $(srcdir)/resources.h
+
+$(objdir)/resources.o: $(srcdir)/resources.rc
+	$(win32_windres) --include-dir $(srcdir) $< $@
+
+$(objdir)/resources.o: $(srcdir)/version.h
diff --git a/src/options.c b/src/options.c
index e1149a4..78721d6 100644
--- a/src/options.c
+++ b/src/options.c
@@ -320,11 +320,18 @@ static SERVICE_OPTIONS new_service_options;
 static const char *option_not_found=
     "Specified option name is not valid here";
 
-static const char *stunnel_cipher_list=
-    "HIGH:!aNULL:!SSLv2:!DH:!kDHEPSK";
+#ifdef WITH_WOLFSSL
+/* Since wolfSSL doesn't support the same naming for cipher strings, we
+ * default to NULL and require the user to specify exact cipher_strings
+ * if they want to limit the cipher list */
+static char *stunnel_cipher_list="DEFAULT";
+#else
+static char *stunnel_cipher_list=
+    "HIGH:!DH:!aNULL:!SSLv2";
+#endif /* WITH_WOLFSSL */
 
 #ifndef OPENSSL_NO_TLS1_3
-static const char *stunnel_ciphersuites=
+static char *stunnel_ciphersuites=
     "TLS_AES_256_GCM_SHA384:TLS_AES_128_GCM_SHA256:TLS_CHACHA20_POLY1305_SHA256";
 #endif /* TLS 1.3 */
 
@@ -1509,7 +1516,7 @@ NOEXPORT const char *parse_service_option(CMD cmd, SERVICE_OPTIONS **section_ptr
         break;
     }
 
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
 
     /* checkEmail */
     switch(cmd) {
@@ -1670,7 +1677,11 @@ NOEXPORT const char *parse_service_option(CMD cmd, SERVICE_OPTIONS **section_ptr
         }
         break;
     case CMD_PRINT_DEFAULTS:
+    #ifdef WITH_WOLFSSL
+        s_log(LOG_NOTICE, "wolfSSL will choose the most secure cipher supported by both client and server");
+    #else
         s_log(LOG_NOTICE, "%-22s = %s %s", "ciphersuites", stunnel_ciphersuites, "(with TLSv1.3)");
+    #endif
         break;
     case CMD_PRINT_HELP:
         s_log(LOG_NOTICE, "%-22s = permitted ciphersuites for TLS 1.3", "ciphersuites");
@@ -3790,7 +3801,9 @@ NOEXPORT const char *parse_service_option(CMD cmd, SERVICE_OPTIONS **section_ptr
     case CMD_FREE:
         str_free(section->chain);
         if(section->session)
+        #ifndef WITH_WOLFSSL
             SSL_SESSION_free(section->session);
+        #endif
         if(section->ctx)
             SSL_CTX_free(section->ctx);
         str_free(section->servname);
diff --git a/src/prototypes.h b/src/prototypes.h
index b62c8c7..2759b17 100644
--- a/src/prototypes.h
+++ b/src/prototypes.h
@@ -238,7 +238,7 @@ typedef struct service_options_struct {
     char *ocsp_url;
     unsigned long ocsp_flags;
 #endif /* !defined(OPENSSL_NO_OCSP) */
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
     NAME_LIST *check_host, *check_email, *check_ip;   /* cert subject checks */
     NAME_LIST *config;                               /* OpenSSL CONF options */
 #endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
@@ -530,6 +530,11 @@ void s_log(int, const char *, ...)
 #else
     ;
 #endif
+
+#ifdef WITH_WOLFSSL
+void wolfSSL_s_log(int , const char *);
+#endif
+
 void s_vlog(int, const char *, va_list);
 char *log_id(CLI *);
 void fatal_debug(const char *, const char *, int) NORETURN;
@@ -727,7 +732,9 @@ int getnameinfo(const struct sockaddr *, socklen_t,
 extern CLI *thread_head;
 #endif
 
-#if OPENSSL_VERSION_NUMBER<0x10100004L
+#ifdef WITH_WOLFSSL
+typedef wolfSSL_Mutex CRYPTO_RWLOCK;
+#elif OPENSSL_VERSION_NUMBER<0x10100004L
 
 #ifdef USE_OS_THREADS
 
@@ -779,12 +786,14 @@ typedef enum {
 extern CRYPTO_RWLOCK *stunnel_locks[STUNNEL_LOCKS];
 
 #if OPENSSL_VERSION_NUMBER<0x10100004L
+#ifndef WITH_WOLFSSL
 /* Emulate the OpenSSL 1.1 locking API for older OpenSSL versions */
 CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
 int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *);
 int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *);
 int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *);
 void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *);
+#endif /* WITH_WOLFSSL */
 int CRYPTO_atomic_add(int *, int, int *, CRYPTO_RWLOCK *);
 #endif
 
diff --git a/src/ssl.c b/src/ssl.c
index 31d03c6..0c6d90e 100644
--- a/src/ssl.c
+++ b/src/ssl.c
@@ -103,7 +103,7 @@ int fips_available() { /* either FIPS provider or container is available */
 
 /* initialize libcrypto before invoking API functions that require it */
 void crypto_init(char *stunnel_dir) {
-#if OPENSSL_VERSION_NUMBER>=0x10100000L
+#if OPENSSL_VERSION_NUMBER>=0x10100000L && !defined(WITH_WOLFSSL)
     OPENSSL_INIT_SETTINGS *conf=OPENSSL_INIT_new();
 #ifdef USE_WIN32
     char *path;
@@ -133,6 +133,7 @@ void crypto_init(char *stunnel_dir) {
 #else /* OPENSSL_VERSION_NUMBER>=0x10100000L */
     (void)stunnel_dir; /* squash the unused parameter warning */
     OPENSSL_config(NULL);
+    SSL_library_init();
     SSL_load_error_strings();
     SSL_library_init();
 #endif /* OPENSSL_VERSION_NUMBER>=0x10100000L */
@@ -401,6 +402,7 @@ NOEXPORT void compression_list() {
 NOEXPORT int prng_init(GLOBAL_OPTIONS *global) {
     int totbytes=0;
     char filename[256];
+#ifndef WITH_WOLFSSL
     const RAND_METHOD *meth=RAND_get_rand_method();
 
     /* skip PRNG initialization when no seeding methods are available */
@@ -408,6 +410,7 @@ NOEXPORT int prng_init(GLOBAL_OPTIONS *global) {
         s_log(LOG_DEBUG, "No PRNG seeding methods");
         return 0; /* success */
     }
+#endif
 
     if(RAND_status()) {
         s_log(LOG_DEBUG, "No PRNG seeding was required");
diff --git a/src/sthreads.c b/src/sthreads.c
index e3e442e..8456c38 100644
--- a/src/sthreads.c
+++ b/src/sthreads.c
@@ -105,7 +105,7 @@ unsigned long stunnel_thread_id(void) {
 
 #endif /* USE_WIN32 */
 
-#if OPENSSL_VERSION_NUMBER>=0x10000000L && OPENSSL_VERSION_NUMBER<0x10100004L
+#if OPENSSL_VERSION_NUMBER>=0x10000000L && OPENSSL_VERSION_NUMBER<0x10100004L && !defined(WITH_WOLFSSL)
 NOEXPORT void threadid_func(CRYPTO_THREADID *tid) {
     CRYPTO_THREADID_set_numeric(tid, stunnel_thread_id());
 }
@@ -125,6 +125,8 @@ NOEXPORT void thread_id_init() {
 /* we only need to initialize locking with OpenSSL older than 1.1.0 */
 #if OPENSSL_VERSION_NUMBER<0x10100004L
 
+#ifndef WITH_WOLFSSL
+
 #ifdef USE_PTHREAD
 
 NOEXPORT void s_lock_init_debug(struct CRYPTO_dynlock_value *lock,
@@ -259,6 +261,8 @@ NOEXPORT void s_lock_destroy_debug(struct CRYPTO_dynlock_value *lock,
 
 #endif /* USE_WIN32 */
 
+#endif /* WITH_WOLFSSL */
+
 NOEXPORT int s_atomic_add(int *val, int amount, CRYPTO_RWLOCK *lock) {
     int ret;
 
@@ -285,6 +289,8 @@ CRYPTO_RWLOCK *stunnel_locks[STUNNEL_LOCKS];
 
 #if OPENSSL_VERSION_NUMBER<0x10100004L
 
+#ifndef WITH_WOLFSSL
+
 #ifdef USE_OS_THREADS
 
 static struct CRYPTO_dynlock_value *lock_cs;
@@ -382,6 +388,8 @@ void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock) {
 
 #endif /* USE_OS_THREADS */
 
+#endif /* WITH_WOLFSSL */
+
 int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock) {
     *ret=s_atomic_add(val, amount, lock);
     return 1;
@@ -391,7 +399,7 @@ int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock) {
 
 NOEXPORT void locking_init() {
     size_t i;
-#if defined(USE_OS_THREADS) && OPENSSL_VERSION_NUMBER<0x10100004L
+#if defined(USE_OS_THREADS) && OPENSSL_VERSION_NUMBER<0x10100004L && !defined(WITH_WOLFSSL)
     size_t num;
 
     /* initialize the OpenSSL static locking */
diff --git a/src/str.c b/src/str.c
index f04cfb3..46a3baa 100644
--- a/src/str.c
+++ b/src/str.c
@@ -93,7 +93,7 @@ NOEXPORT LEAK_ENTRY leak_hash_table[LEAK_TABLE_SIZE],
     *leak_results[LEAK_TABLE_SIZE];
 NOEXPORT int leak_result_num=0;
 
-#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(WITH_WOLFSSL)
 DEFINE_STACK_OF(LEAK_ENTRY)
 #endif /* OpenSSL version >= 1.1.1 */
 
@@ -107,7 +107,9 @@ NOEXPORT ALLOC_LIST *get_alloc_list_ptr(void *, const char *, int);
 NOEXPORT void str_leak_debug(const ALLOC_LIST *, int);
 
 NOEXPORT LEAK_ENTRY *leak_search(const ALLOC_LIST *);
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(WITH_WOLFSSL)
 NOEXPORT int leak_cmp(const LEAK_ENTRY *const *, const LEAK_ENTRY *const *);
+#endif /* OpenSSL version >= 1.1.1 */
 NOEXPORT void leak_report(void);
 NOEXPORT long leak_threshold(void);
 
@@ -563,7 +565,7 @@ NOEXPORT LEAK_ENTRY *leak_search(const ALLOC_LIST *alloc_list) {
 void leak_table_utilization() {
     int i, utilization=0;
     int64_t grand_total=0;
-#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(WITH_WOLFSSL)
     STACK_OF(LEAK_ENTRY) *stats;
 #endif /* OpenSSL version >= 1.1.1 */
 
@@ -580,7 +582,7 @@ void leak_table_utilization() {
     s_log(LOG_DEBUG, "Leak detection table utilization: %d/%d (%05.2f%%)",
         utilization, LEAK_TABLE_SIZE, 100.0*utilization/LEAK_TABLE_SIZE);
 
-#if OPENSSL_VERSION_NUMBER >= 0x10101000L
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(WITH_WOLFSSL)
     /* log up to 5 most frequently used heap allocations */
     stats=sk_LEAK_ENTRY_new_reserve(leak_cmp, utilization);
     for(i=0; i<LEAK_TABLE_SIZE; ++i)
@@ -597,6 +599,7 @@ void leak_table_utilization() {
 #endif /* OpenSSL version >= 1.1.1 */
 }
 
+#if OPENSSL_VERSION_NUMBER >= 0x10101000L && !defined(WITH_WOLFSSL)
 NOEXPORT int leak_cmp(const LEAK_ENTRY *const *a, const LEAK_ENTRY *const *b) {
     int64_t d = (*a)->total - (*b)->total;
     if(d>0)
@@ -605,6 +608,7 @@ NOEXPORT int leak_cmp(const LEAK_ENTRY *const *a, const LEAK_ENTRY *const *b) {
         return -1;
     return 0;
 }
+#endif /* OpenSSL version >= 1.1.1 */
 
 /* report identified leaks */
 NOEXPORT void leak_report() {
diff --git a/src/stunnel.c b/src/stunnel.c
index 4b4e06a..50d65fe 100644
--- a/src/stunnel.c
+++ b/src/stunnel.c
@@ -47,7 +47,9 @@
 #pragma GCC diagnostic ignored "-Wpedantic"
 #endif /* __GNUC__ */
 
+#ifndef WITH_WOLFSSL
 #include <openssl/applink.c>
+#endif
 
 #ifdef __GNUC__
 #if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)
@@ -126,6 +128,10 @@ void main_init() { /* one-time initialization */
         fatal("TLS initialization failed");
     if(sthreads_init()) /* initialize critical sections & TLS callbacks */
         fatal("Threads initialization failed");
+#ifdef WITH_WOLFSSL
+    if(ssl_init()) /* initialize TLS library */
+        fatal("TLS initialization failed");
+#endif
     options_defaults(); /* initialize defaults */
     options_apply(); /* apply the defaults */
 #ifndef USE_FORK
diff --git a/src/ui_unix.c b/src/ui_unix.c
index a24f2ff..bd59d32 100644
--- a/src/ui_unix.c
+++ b/src/ui_unix.c
@@ -71,6 +71,10 @@ NOEXPORT int main_unix(int argc, char* argv[]) {
         fatal("Could not open /dev/null");
 #endif
     main_init();
+#ifdef WITH_WOLFSSL
+    wolfSSL_Debugging_ON();
+    wolfSSL_SetLoggingCb(wolfSSL_s_log);
+#endif
     configure_status=main_configure(argc>1 ? argv[1] : NULL,
         argc>2 ? argv[2] : NULL);
     switch(configure_status) {
diff --git a/src/ui_win_cli.c b/src/ui_win_cli.c
index 9b54bb4..a8a0bcc 100644
--- a/src/ui_win_cli.c
+++ b/src/ui_win_cli.c
@@ -74,6 +74,10 @@ int main(int argc, char *argv[]) {
         return 1;
     resolver_init();
     main_init();
+#ifdef WITH_WOLFSSL
+    wolfSSL_Debugging_ON();
+    wolfSSL_SetLoggingCb(wolfSSL_s_log);
+#endif
     if(!main_configure(argc>1 ? argv[1] : NULL, argc>2 ? argv[2] : NULL))
         daemon_loop();
     main_cleanup();
diff --git a/src/ui_win_gui.c b/src/ui_win_gui.c
index c508d1a..b7ad1ad 100644
--- a/src/ui_win_gui.c
+++ b/src/ui_win_gui.c
@@ -91,8 +91,10 @@ NOEXPORT void peer_menu_update(void);
 NOEXPORT void peer_menu_update_unlocked(void);
 NOEXPORT void peer_cert_save(WPARAM wParam);
 
+#ifndef WITH_WOLFSSL
 /* UI callbacks */
 NOEXPORT int pin_cb(UI *, UI_STRING *);
+#endif
 
 /* log handling */
 NOEXPORT void log_save(void);
@@ -195,6 +197,10 @@ int WINAPI WinMain(HINSTANCE this_instance, HINSTANCE prev_instance,
     (void)nCmdShow; /* squash the unused parameter warning */
 
     tls_init(); /* initialize thread-local storage */
+#ifdef WITH_WOLFSSL
+    wolfSSL_Debugging_ON();
+    wolfSSL_SetLoggingCb(wolfSSL_s_log);
+#endif
     ghInst=this_instance;
 
     /* set current working directory and engine path */
@@ -1181,7 +1187,7 @@ int ui_passwd_cb(char *buf, int size, int rwflag, void *userdata) {
     return len;
 }
 
-#ifndef OPENSSL_NO_ENGINE
+#if !defined(OPENSSL_NO_ENGINE) && !defined(WITH_WOLFSSL)
 
 NOEXPORT int pin_cb(UI *ui, UI_STRING *uis) {
     if(!DialogBox(ghInst, TEXT("PassBox"), hwnd, (DLGPROC)pass_proc))
diff --git a/src/verify.c b/src/verify.c
index 4058d6c..2de2e6e 100644
--- a/src/verify.c
+++ b/src/verify.c
@@ -42,30 +42,34 @@
 /* verify initialization */
 NOEXPORT void set_client_CA_list(SERVICE_OPTIONS *section);
 NOEXPORT void auth_warnings(SERVICE_OPTIONS *);
+#ifndef WITH_WOLFSSL
 NOEXPORT int crl_init(SERVICE_OPTIONS *section);
 NOEXPORT int load_file_lookup(X509_STORE *, char *);
 NOEXPORT int add_dir_lookup(X509_STORE *, char *);
+#endif /*WITH_WOLFSSL*/
 
 /* verify callback */
 NOEXPORT int verify_callback(int, X509_STORE_CTX *);
 NOEXPORT int verify_checks(CLI *, int, X509_STORE_CTX *);
 NOEXPORT int cert_check(CLI *, X509_STORE_CTX *, int);
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
 NOEXPORT int cert_check_subject(CLI *, X509_STORE_CTX *);
 #endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
 NOEXPORT int cert_check_local(X509_STORE_CTX *);
 NOEXPORT int compare_pubkeys(X509 *, X509 *);
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
 NOEXPORT int ocsp_check(CLI *, X509_STORE_CTX *);
 NOEXPORT int ocsp_request(CLI *, X509_STORE_CTX *, OCSP_CERTID *, char *);
 NOEXPORT OCSP_RESPONSE *ocsp_get_response(CLI *, OCSP_REQUEST *, char *);
-#endif
+#endif /*!defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL) */
 
 /* utility functions */
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
 NOEXPORT X509 *get_current_issuer(X509_STORE_CTX *);
-NOEXPORT void log_time(const int, const char *, ASN1_TIME *);
 #endif
+#ifndef WITH_WOLFSSL
+NOEXPORT void log_time(const int, const char *, ASN1_TIME *);
+#endif /* !defined(WITH_WOLFSSL) */
 
 /**************************************** verify initialization */
 
@@ -84,9 +88,69 @@ int verify_init(SERVICE_OPTIONS *section) {
         set_client_CA_list(section); /* only performed on the server */
 
     /* CRL initialization */
-    if(section->crl_file || section->crl_dir)
+    if(section->crl_file || section->crl_dir) {
+#ifdef WITH_WOLFSSL
+        /* WOLFSSL handles CRL internally, no need to deal with lookups */
+        if(wolfSSL_CTX_EnableCRL(section->ctx, WOLFSSL_CRL_CHECKALL)
+                                                        != SSL_SUCCESS) {
+            sslerror("SSL_CTX_EnableCRL");
+            return 1; /* FAILED */
+        }
+        if (section->crl_file) {
+            if (wolfSSL_CTX_LoadCRLFile(section->ctx, section->crl_file,
+                      SSL_FILETYPE_PEM) != SSL_SUCCESS)
+            {
+                sslerror("SSL_CTX_LoadCRL");
+                return 1; /* FAILED */
+            }
+        }
+        if(section->crl_dir) {
+            if (wolfSSL_CTX_LoadCRL(section->ctx, section->crl_dir,
+                      SSL_FILETYPE_PEM, 0) != SSL_SUCCESS)
+            {
+                sslerror("SSL_CTX_LoadCRL");
+                return 1; /* FAILED */
+            }
+        }
+#else
         if(crl_init(section))
             return 1; /* FAILED */
+#endif /*WITH_WOLFSSL*/
+    }
+
+#ifdef WITH_WOLFSSL
+    if(section->ocsp_url)
+    {
+        if(wolfSSL_CTX_SetOCSP_OverrideURL(section->ctx, section->ocsp_url)
+                != SSL_SUCCESS) {
+            s_log(LOG_ERR, "Error setting OCSP Override URL to: %s)",
+                    section->ocsp_url);
+            sslerror("wolfSSL_CTX_SetOCSP_OverrideURL");
+            return 1; /* FAILED */
+        }
+        if(wolfSSL_CTX_EnableOCSP(section->ctx,
+                WOLFSSL_OCSP_URL_OVERRIDE) != SSL_SUCCESS) {
+            s_log(LOG_ERR, "Error enabling OCSP");
+            sslerror("wolfSSL_CTX_EnableOCSP");
+            return 1; /* FAILED */
+        }
+        s_log(LOG_DEBUG, "Enabled OCSP at URL: %s", section->ocsp_url);
+    }
+    if(section->option.aia==1)
+    {
+        if(section->ocsp_url) {
+            s_log(LOG_ERR, "Error: Cannot set ocsp lookup url with aia.");
+            s_log(LOG_ERR,"Please choose one. Error enabling OCSP");
+            sslerror("wolfSSL_CTX_EnableOCSP");
+        }
+        if(wolfSSL_CTX_EnableOCSP(section->ctx, 0) != SSL_SUCCESS) {
+            s_log(LOG_ERR, "Error enabling OCSP");
+            sslerror("wolfSSL_CTX_EnableOCSP");
+            return 1; /* FAILED */
+        }
+        s_log(LOG_INFO, "Enabled OCSP with aia extension.");
+    }
+#endif /* ifdef WITH_WOLFSSL */
 
     /* verify callback setup */
     if(section->option.request_cert) {
@@ -110,6 +174,7 @@ NOEXPORT void set_client_CA_list(SERVICE_OPTIONS *section) {
     print_client_CA_list(ca_dn);
 }
 
+#ifndef WITH_WOLFSSL
 NOEXPORT int crl_init(SERVICE_OPTIONS *section) {
     X509_STORE *store;
 
@@ -163,6 +228,7 @@ NOEXPORT int add_dir_lookup(X509_STORE *store, char *name) {
     s_log(LOG_DEBUG, "Added %s revocation lookup directory", name);
     return 0; /* OK */
 }
+#endif /*WITH_WOLFSSL*/
 
 /* issue warnings on insecure/missing authentication */
 NOEXPORT void auth_warnings(SERVICE_OPTIONS *section) {
@@ -200,7 +266,7 @@ NOEXPORT void auth_warnings(SERVICE_OPTIONS *section) {
 /**************************************** verify callback */
 
 NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {
-        /* our verify callback function */
+    /* our verify callback function */
     SSL *ssl;
     CLI *c;
 
@@ -209,7 +275,7 @@ NOEXPORT int verify_callback(int preverify_ok, X509_STORE_CTX *callback_ctx) {
         SSL_get_ex_data_X509_STORE_CTX_idx());
     c=SSL_get_ex_data(ssl, index_ssl_cli);
 
-    if(!c->opt->option.verify_chain && !c->opt->option.verify_peer) {
+    if(!c || (!c->opt->option.verify_chain && !c->opt->option.verify_peer)) {
         s_log(LOG_INFO, "Certificate verification disabled");
         return 1; /* accept */
     }
@@ -250,14 +316,14 @@ NOEXPORT int verify_checks(CLI *c,
         str_free(subject);
         return 0; /* reject */
     }
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
     if((c->opt->ocsp_url || c->opt->option.aia) &&
             !ocsp_check(c, callback_ctx)) {
         s_log(LOG_WARNING, "Rejected by OCSP at depth=%d: %s", depth, subject);
         str_free(subject);
         return 0; /* reject */
     }
-#endif /* !defined(OPENSSL_NO_OCSP) */
+#endif /* !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL) */
 
     s_log(depth ? LOG_INFO : LOG_NOTICE,
         "Certificate accepted at depth=%d: %s", depth, subject);
@@ -289,10 +355,10 @@ NOEXPORT int cert_check(CLI *c, X509_STORE_CTX *callback_ctx,
     }
 
     if(depth==0) { /* additional peer certificate checks */
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL)
         if(!cert_check_subject(c, callback_ctx))
             return 0; /* reject */
-#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
+#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL) */
         if(c->opt->option.verify_peer && !cert_check_local(callback_ctx))
             return 0; /* reject */
     }
@@ -300,7 +366,7 @@ NOEXPORT int cert_check(CLI *c, X509_STORE_CTX *callback_ctx,
     return 1; /* accept */
 }
 
-#if OPENSSL_VERSION_NUMBER>=0x10002000L
+#if OPENSSL_VERSION_NUMBER>=0x10002000L  || defined(WITH_WOLFSSL)
 NOEXPORT int cert_check_subject(CLI *c, X509_STORE_CTX *callback_ctx) {
     X509 *cert=X509_STORE_CTX_get_current_cert(callback_ctx);
     NAME_LIST *ptr;
@@ -336,7 +402,7 @@ NOEXPORT int cert_check_subject(CLI *c, X509_STORE_CTX *callback_ctx) {
     s_log(LOG_WARNING, "CERT: Subject checks failed");
     return 0; /* reject */
 }
-#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L */
+#endif /* OPENSSL_VERSION_NUMBER>=0x10002000L || defined(WITH_WOLFSSL) */
 
 #if OPENSSL_VERSION_NUMBER>=0x10000000L
 /* modern implementation for OpenSSL version >= 1.0.0 */
@@ -350,7 +416,7 @@ NOEXPORT int cert_check_local(X509_STORE_CTX *callback_ctx) {
     cert=X509_STORE_CTX_get_current_cert(callback_ctx);
     subject=X509_get_subject_name(cert);
 
-#if OPENSSL_VERSION_NUMBER<0x10100006L
+#if OPENSSL_VERSION_NUMBER<0x10100006L || defined(WITH_WOLFSSL)
 #define X509_STORE_CTX_get1_certs X509_STORE_get1_certs
 #endif
     /* modern API allows retrieving multiple matching certificates */
@@ -402,6 +468,44 @@ NOEXPORT int cert_check_local(X509_STORE_CTX *callback_ctx) {
 #endif /* OPENSSL_VERSION_NUMBER>=0x10000000L */
 
 NOEXPORT int compare_pubkeys(X509 *c1, X509 *c2) {
+#ifdef WITH_WOLFSSL
+    int c1Sz;
+    unsigned char *c1Data;
+    int c2Sz;
+    unsigned char *c2Data;
+    int ret;
+
+    /* First, call wolfSSL_X509_get_pubkey_buffer with NULL buffer, to get 
+     * the required buffer size. */
+    ret = wolfSSL_X509_get_pubkey_buffer(c1, NULL, &c1Sz);
+    if (ret != WOLFSSL_SUCCESS) {
+        return 0; /* reject */
+    }
+    c1Data = (unsigned char*) malloc((size_t)c1Sz);
+    
+    ret = wolfSSL_X509_get_pubkey_buffer(c2, NULL, &c2Sz);
+    if (ret != WOLFSSL_SUCCESS) {
+        return 0; /* reject */
+    }
+    c2Data = (unsigned char*) malloc((size_t)c2Sz);
+
+    if (c1Data == NULL
+     || c2Data == NULL
+     || wolfSSL_X509_get_pubkey_buffer(c1, c1Data, &c1Sz) != WOLFSSL_SUCCESS
+     || wolfSSL_X509_get_pubkey_buffer(c2, c2Data, &c2Sz) != WOLFSSL_SUCCESS
+     || c1Sz != c2Sz || safe_memcmp(c1Data, c2Data, (size_t)c1Sz)) {
+        ret = 0; /* reject */
+    }
+    else {
+        ret = 1; /* accept */
+        s_log(LOG_INFO, "CERT: Locally installed certificate matched");
+    }
+
+    free(c1Data);
+    free(c2Data);
+
+    return ret;
+#else
     ASN1_BIT_STRING *k1=X509_get0_pubkey_bitstr(c1);
     ASN1_BIT_STRING *k2=X509_get0_pubkey_bitstr(c2);
     if(!k1 || !k2 || k1->length!=k2->length || k1->length<0 ||
@@ -409,11 +513,12 @@ NOEXPORT int compare_pubkeys(X509 *c1, X509 *c2) {
         return 0; /* reject */
     s_log(LOG_INFO, "CERT: Locally installed certificate matched");
     return 1; /* accept */
+#endif
 }
 
 /**************************************** OCSP checking */
 
-#ifndef OPENSSL_NO_OCSP
+#if !defined(OPENSSL_NO_OCSP) && !defined(WITH_WOLFSSL)
 
 #ifdef DEFINE_STACK_OF
 /* defined in openssl/safestack.h:
@@ -734,7 +839,7 @@ NOEXPORT void log_time(const int level, const char *txt, ASN1_TIME *t) {
     str_free(cp);
 }
 
-#endif /* !defined(OPENSSL_NO_OCSP) */
+#endif /* !defined(OPENSSL_NO_OCSP)  && !defined(WITH_WOLFSSL) */
 
 void print_client_CA_list(const STACK_OF(X509_NAME) *ca_dn) {
     char *ca_name;
@@ -758,6 +863,15 @@ void print_client_CA_list(const STACK_OF(X509_NAME) *ca_dn) {
 
 char *X509_NAME2text(X509_NAME *name) {
     char *text;
+#ifdef WITH_WOLFSSL
+    int sz;
+    sz=wolfSSL_X509_NAME_get_sz(name);
+    if(sz<=0)
+        return str_dup("Invalid X509_NAME");
+    text=str_alloc((size_t)sz+1); /* one byte for '\0' excape */
+    text=wolfSSL_X509_NAME_oneline(name, text, sz);
+    text[sz]='\0';
+#else
     BIO *bio;
     int n;
 
@@ -776,6 +890,7 @@ char *X509_NAME2text(X509_NAME *name) {
     }
     text[n]='\0';
     BIO_free(bio);
+#endif /* WITH_WOLFSSL */
     return text;
 }
 
diff --git a/tests/maketest.py b/tests/maketest.py
index 8443dbc..11f60d9 100644
--- a/tests/maketest.py
+++ b/tests/maketest.py
@@ -51,8 +51,8 @@ RE_STUNNEL_VERSION = re.compile(
 
 RE_OPENSSL_VERSION = re.compile(
     r""" ^
-    Compiled\/running\swith\sOpenSSL\s+
-    (?P<version> (?: [0-3]\.[0-9]\.[0-9]* ) \S+)
+    Compiled\/running\swith\s((OpenSSL)|(wolfSSL))\s+
+    (?P<version> (?: [0-5]\.[0-9]\.[0-9]* ) \S+)
     (?: \s .* )?
     $ """,
     re.X
@@ -175,6 +175,7 @@ class Config(NamedTuple):
     results: pathlib.Path
     summary: pathlib.Path
     debug: int
+    plugin: str
 
 
 class TestConnections(NamedTuple):
@@ -1619,6 +1620,13 @@ def parse_args() -> Config:
         help="the logging level "
         "(default: INFO)",
     )
+    parser.add_argument(
+        "--plugin",
+        type=str,
+        default=None,
+        help="the plugin to run "
+        "(default: All)",
+    )
     args = parser.parse_args()
     utf8_env = dict(os.environ)
     utf8_env.update({
@@ -1646,7 +1654,8 @@ def parse_args() -> Config:
             utf8_env=utf8_env,
             results=os.path.join(args.logs, "results.log"),
             summary=os.path.join(args.logs, "summary.log"),
-            debug=args.debug
+            debug=args.debug,
+            plugin=args.plugin,
         )
 
 
diff --git a/tests/plugin_collection.py b/tests/plugin_collection.py
index b06bcc5..5fd9fe2 100644
--- a/tests/plugin_collection.py
+++ b/tests/plugin_collection.py
@@ -4,6 +4,7 @@ import dataclasses
 import inspect
 import os
 import pkgutil
+import time
 
 
 @dataclasses.dataclass(frozen=True)
@@ -83,6 +84,9 @@ class PluginCollection():
             )
         )
         for plugin in self.plugins:
+            if self.cfg.plugin is not None and plugin.__module__.replace('plugins.', '') != self.cfg.plugin:
+                time.sleep(0.1)
+                continue
             await self.cfg.mainq.put(LogEvent(etype="log", level=20, log=""))
             await self.cfg.mainq.put(
                 LogEvent(
diff --git a/tests/plugins/p08_ipv6.py b/tests/plugins/p08_ipv6.py
index 2483a54..165d689 100644
--- a/tests/plugins/p08_ipv6.py
+++ b/tests/plugins/p08_ipv6.py
@@ -25,6 +25,9 @@ class IPv6Test(StunnelTest):
     def __init__(self, cfg: Config, logger: logging.Logger):
         super().__init__(cfg, logger)
         self.params.description = '081. Test IPv6 support'
+        self.events.skip = [
+            "Cannot assign requested address"
+        ]
         self.events.failure = [
             "peer did not return a certificate",
             "bad certificate",
@@ -94,5 +97,13 @@ class StunnelClientTest(Plugin):
 
     async def perform_operation(self, cfg: Config, logger: logging.Logger) -> None:
         """Run tests"""
+        try:
+            # check that ipv6 is supported
+            import socket
+            s = socket.socket(family=socket.AF_INET6)
+            s.bind(('::1', 12345))
+            s.close()
+        except OSError:
+            return
         stunnel = IPv6Test(cfg, logger)
         await stunnel.test_stunnel(cfg)
diff --git a/tests/plugins/p10_fips.py b/tests/plugins/p10_fips.py
index 5d2bc56..f2e148e 100644
--- a/tests/plugins/p10_fips.py
+++ b/tests/plugins/p10_fips.py
@@ -28,6 +28,7 @@ class FIPSTest(StunnelTest):
         self.params.description = '101. Test FIPS mode'
         self.events.skip = [
             "FIPS provider not available",
+            "FIPS support is not available",
             "fips mode not supported",
             r"FIPS PROVIDER.*could not load the shared library"
         ]
diff --git a/tests/plugins/p11_fips_cipher.py b/tests/plugins/p11_fips_cipher.py
index 0280a1d..f1bc721 100644
--- a/tests/plugins/p11_fips_cipher.py
+++ b/tests/plugins/p11_fips_cipher.py
@@ -29,6 +29,7 @@ class FailureCipherFIPS(StunnelTest):
         self.params.description = '111. Failure FIPS mode with unavailable cipher'
         self.events.skip = [
             "FIPS provider not available",
+            "FIPS support is not available",
             "fips mode not supported",
             r"FIPS PROVIDER.*could not load the shared library"
         ]
@@ -86,6 +87,7 @@ class FailureCiphersuitesFIPS(StunnelTest):
         self.params.description = '112. Failure FIPS mode with unavailable ciphersuite'
         self.events.skip = [
             "FIPS provider not available",
+            "FIPS support is not available",
             "fips mode not supported",
             r"FIPS PROVIDER.*could not load the shared library",
             "Specified option name is not valid here"
@@ -146,6 +148,7 @@ class FailureEllipticCurveFIPS(StunnelTest):
         self.params.description = '113. Failure FIPS mode with unavailable elliptic curve'
         self.events.skip = [
             "FIPS provider not available",
+            "FIPS support is not available",
             "fips mode not supported",
             r"FIPS PROVIDER.*could not load the shared library"
         ]
diff --git a/tests/plugins/p16_redirect.py b/tests/plugins/p16_redirect.py
index dd29a19..fd71874 100644
--- a/tests/plugins/p16_redirect.py
+++ b/tests/plugins/p16_redirect.py
@@ -33,7 +33,7 @@ class RedirectWrongPeerCert(StunnelTest):
         self.events.failure = [
             "peer did not return a certificate",
             "bad certificate",
-            "certificate verify failed",
+            # "certificate verify failed",
             "unsupported protocol",
             "TLS accepted: previous session reused",
             #"Redirecting connection",
@@ -134,7 +134,7 @@ class NoRedirectCorrectPeerCert(StunnelTest):
         self.events.failure = [
             "peer did not return a certificate",
             "bad certificate",
-            "certificate verify failed",
+            # "certificate verify failed",
             "unsupported protocol",
             "TLS accepted: previous session reused",
             "Redirecting connection",
@@ -185,7 +185,7 @@ class RedirectWrongChainCert(StunnelTest):
         self.events.failure = [
             "peer did not return a certificate",
             "bad certificate",
-            "certificate verify failed",
+            # "certificate verify failed",
             "unsupported protocol",
             "TLS accepted: previous session reused",
             #"Redirecting connection",
diff --git a/tests/plugins/p17_redirect_proxy.py b/tests/plugins/p17_redirect_proxy.py
index 437d91d..44e7874 100644
--- a/tests/plugins/p17_redirect_proxy.py
+++ b/tests/plugins/p17_redirect_proxy.py
@@ -33,7 +33,7 @@ class RedirectProxyWrongPeerCert(StunnelTest):
         self.events.failure = [
             "peer did not return a certificate",
             "bad certificate",
-            "certificate verify failed",
+            # "certificate verify failed",
             "unsupported protocol",
             "TLS accepted: previous session reused",
             #"Redirecting connection",
diff --git a/tests/plugins/p18_redirect_resume.py b/tests/plugins/p18_redirect_resume.py
index a0030c0..893b0f4 100644
--- a/tests/plugins/p18_redirect_resume.py
+++ b/tests/plugins/p18_redirect_resume.py
@@ -39,7 +39,7 @@ class ResumeRedirectWrongCert(StunnelTest):
         self.events.failure = [
             "peer did not return a certificate",
             "bad certificate",
-            "certificate verify failed",
+            # "certificate verify failed",
             "unsupported protocol",
             #"TLS accepted: previous session reused",
             #"Redirecting connection",
